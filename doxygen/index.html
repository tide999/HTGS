<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: Hybrid Task Graph Scheduler (HTGS) - An application programming interface to generate hybrid pipeline workflow systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Hybrid Task Graph Scheduler (HTGS) - An application programming interface to generate hybrid pipeline workflow systems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#installation">Installation </a></li>
<li class="level1"><a href="#approach">Approach </a></li>
<li class="level1"><a href="#methodlogy">HTGS Design Methodology </a></li>
<li class="level1"><a href="#overview">Overview of HTGS </a></li>
<li class="level1"><a href="#tutorials">Tutorials </a></li>
</ul>
</div>
<div class="textblock"><p>Disclaimer: NIST-developed software is provided by NIST as a public service. You may use, copy and distribute copies of the software in any medium, provided that you keep intact this entire notice. You may improve, modify and create derivative works of the software or any portion of the software, and you may copy and distribute such modifications or works. Modified works should carry a notice stating that you changed the software and should note the date and nature of any such change. Please explicitly acknowledge the National Institute of Standards and Technology as the source of the software.</p>
<p>NIST-developed software is expressly provided “AS IS.” NIST MAKES NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.</p>
<p>You are solely responsible for determining the appropriateness of using and distributing the software and you assume all risks associated with its use, including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and the unavailability or interruption of operation. This software is not intended to be used in any situation where a failure could cause risk of injury or damage to property. The software developed by NIST employees is not subject to copyright protection within the United States.</p>
<dl class="section author"><dt>Author</dt><dd>Timothy Blattner</dd></dl>
<hr/>
<h1><a class="anchor" id="installation"></a>
Installation </h1>
<p><a class="el" href="install-instructions.html">Getting Started</a></p>
<hr/>
<h1><a class="anchor" id="approach"></a>
Approach </h1>
<p>The intent of the Hybrid Task Graph Scheduler (HTGS) API is to transform an algorithm into a pipelined workflow system, which aims at fully utilizing a high performance compute system (multi-core CPUs, multiple accelerators, and high-speed I/O). HTGS defines an abstract execution model, framework, and API.</p>
<p>The HTGS model combines two paradigms, dataflow and task scheduling. Dataflow semantics represents an algorithm at a high-level of abstraction as a dataflow graph, similar to signal processing dataflow graphs. Task scheduling provides the threading model. A variant of task scheduling is used in which a task is assigned a pool of threads, which processes data using a shared queue. In this way data is sent to each task, which processes each item independently using the thread pool. This method of parallelism and orchestration requires a deep understanding of an algorithm and how to decompose the problem domain, which is required when parallelizing any algorithm.</p>
<p>The HTGS framework defines the components for building HTGS task graphs: tasks, bookkeepers, memory managers, and execution pipelines. These components are defined in such a way to provide a separation of concerns between computation, state maintenance, memory, and scalability. Through this representation an algorithm can be approached at a high level of abstraction.</p>
<p>The HTGS API is used to implement an algorithm that is represented within the HTGS framework. The API is designed in such a way that the graph representation from the model and framework is explicit. This allows for mapping the analysis phase of using HTGS with the implementation (and back). The primary use of this representation is to allow rapid prototyping and experimentation for performance.</p>
<p>The general idea with using HTGS is to overlap I/O with computation. I/O can be represented by disk, network, PCI express, or any metric that involves shipping data closer to the compute hardware. HTGS tasks should operate within memory for that compute hardware, such that the underlying task implementation be designed to improve utilization on the desired architecture (i.e. use vector processing units). Ultimately, HTGS provides abstractions for four components, which we treat as first-class issues: (1) Memory management, (2) Concurrency, (3) Expressing data locality, and (4) Managing data dependencies.</p>
<h1><a class="anchor" id="methodlogy"></a>
HTGS Design Methodology </h1>
<p>There are five steps in the HTGS design methodology, as shown below. The first three steps are <em>white-board</em> stages; the remaining steps are coding and revisiting of the pictoral stages.</p>
<div class="image">
<img src="Methodology.png" alt="Methodology.png"/>
</div>
<h2>1. Parallel Algorithm Design</h2>
<ul>
<li>Represent algorithm as a parallel algorithm where computational kernels are laid out as a series of modular functions.</li>
</ul>
<h2>2. Represent as Dataflow</h2>
<ul>
<li>Map computational functions to nodes</li>
<li>Edges are data dependencies<ul>
<li>Annotate edges with data types/parameters</li>
</ul>
</li>
</ul>
<h2>3. HTGS Task Graph Design</h2>
<ul>
<li>Computational entities are tasks</li>
<li>Dependencies are managed by Bookkeeper</li>
</ul>
<h2>4. HTGS API Coding</h2>
<ul>
<li>Implement using the HTGS API</li>
<li>One Create a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> for each computational entity.</li>
<li><a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> is used to represent any data that is needed for each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a><ul>
<li><a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> is transmitted as input and output from a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>, which is based on the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>'s template types T, U, respectively.</li>
</ul>
</li>
<li>Process dependencies using <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a><ul>
<li>Uses <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> to process dependencies</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> determines when to produce work</li>
</ul>
</li>
<li>Connect each task using the <a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01" title="Adds an edge to the graph, where one task produces data for a consumer task. ">htgs::TaskGraphConf::addEdge</a> or <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">htgs::TaskGraphConf::addRuleEdge</a></li>
<li>Debug using dot file generation with <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a><ul>
<li>Real-time visualization (coming soon)</li>
</ul>
</li>
</ul>
<h2>5. Refine and Optimize</h2>
<ul>
<li>Modify data granularity and scheduling behavior<ul>
<li>Improve data locality and data reuse</li>
</ul>
</li>
<li>Create CUDA variants with <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">htgs::ICudaTask</a><ul>
<li>Add <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">htgs::ICudaTask</a> to copy data to/from GPU before/after CUDA variant</li>
</ul>
</li>
<li>Scale to multiple GPUs with <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a></li>
<li>Use HTGS profiling (add the directive "-DPROFILE" in compilation)<ul>
<li>Output the graph after execution using <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a></li>
<li>Visually identify bottlenecks</li>
</ul>
</li>
<li>Add memory edges where necessary to regulate memory with <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">htgs::TaskGraphConf::addMemoryManagerEdge</a><ul>
<li>Restricts the amount of memory transmitted through graph</li>
<li>Defines data reuse with programmer-defined <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a></li>
</ul>
</li>
<li>Real-time visualization (coming soon)</li>
</ul>
<h1><a class="anchor" id="overview"></a>
Overview of HTGS </h1>
<p>The HTGS API is split into two modules:</p><ol type="1">
<li>The User API<ul>
<li>Classes that begin with 'I' denote interfaces that are to be implemented: <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>, <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>, etc.</li>
</ul>
</li>
<li>The Core API</li>
</ol>
<p>The user API is found in &lt;htgs/api/...&gt; and contains the API that programmers use to create a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>. The majority of programs should only use the User API.</p>
<p>The core API is found in &lt;htgs/core/...&gt; and holds the underlying sub-systems that the user API operates with.</p>
<p>Although there is a separation between the user and core APIs, there are methods to add high-level abstractions that can be used to new functionality into HTGS. The <a class="el" href="classhtgs_1_1_edge_descriptor.html" title="The edge descriptor is an interface used to describe how an edge is applied and copied to a task grap...">htgs::EdgeDescriptor</a> is one such abstraction that is used as an interface to describe how an edge connecting one or more tasks is applied to a task graph and copied. This can be extended to create new types of edges. Currently the <a class="el" href="classhtgs_1_1_producer_consumer_edge.html" title="Implements the producer consumer edge that connects two tasks where one task is producing data and th...">htgs::ProducerConsumerEdge</a>, <a class="el" href="classhtgs_1_1_rule_edge.html" title="Implements the rule edge that is added to the graph. ">htgs::RuleEdge</a>, and <a class="el" href="classhtgs_1_1_memory_edge.html" title="Implements the memory edge that is added to the graph. ">htgs::MemoryEdge</a> are used to define how to connect tasks for the <a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01" title="Adds an edge to the graph, where one task produces data for a consumer task. ">htgs::TaskGraphConf::addEdge</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">htgs::TaskGraphConf::addRuleEdge</a>, and <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">htgs::TaskGraphConf::addMemoryManagerEdge</a> functions, respectively.</p>
<h1><a class="anchor" id="tutorials"></a>
Tutorials </h1>
<ul>
<li><a class="el" href="tutorial0.html">Tutorial 0</a> - Getting started with the HTGS Tutorials - <a href="https://github.com/usnistgov/HTGS-Tutorials">HTGS Tutorials Github</a><ul>
<li>Compiling and running the tutorials</li>
<li>Using the command-line with the HTGS Tutorials</li>
<li>Using CLion with the HTGS Tutorials</li>
<li>Using Eclipse CDT with the HTGS Tutorials</li>
</ul>
</li>
<li><a class="el" href="tutorial1.html">Tutorial 1</a> - Adding two numbers in HTGS - <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial1">Source Code</a><ul>
<li>Making a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>Creating <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a></li>
<li>Using the htgs:TaskGraphConf</li>
<li>Executing with the <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a></li>
<li>How to interact with the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
</ul>
</li>
<li><a class="el" href="tutorial2a.html">Tutorial 2a</a> - Implementing the HadamardProduct - <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial2">Source Code</a><ul>
<li>Creating a dependency with the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> and <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a></li>
<li>Methods for domain decomposition</li>
<li>Debugging</li>
</ul>
</li>
<li><a class="el" href="tutorial2b.html">Tutorial 2b</a> - Augmenting the graph from Tutorial 2a to use disk - [Source Code]()<ul>
<li>Managing memory<ul>
<li>Basic <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> and <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a></li>
<li>How to <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a></li>
<li>How to <a class="el" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba" title="Releases memory onto a memory edge, which is transferred by the graph communicator. ">htgs::ITask::releaseMemory</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="tutorial3a.html">Tutorial 3a</a> - Implementing Matrix Multiplication [Source Code]()<ul>
<li>Complex dependencies</li>
<li>Terminating cyclic graphs</li>
<li>Profiling and optimizations</li>
</ul>
</li>
<li><a class="el" href="tutorial3b.html">Tutorial 3b</a> - Profiling and debugging the graph from Tutorial 3a.<ul>
<li>GraphViz visualizations</li>
<li>Development experimentation for performance</li>
<li>Identifying bottlenecks</li>
<li>Incorporating high performance libraries into HTGS tasks <hr/>
 <h2>Tutorials below are still under development </h2>
</li>
</ul>
</li>
<li>Tutorial 3c - Augmenting the graph from Tutorial3a to use memory mapped files.<ul>
<li>How to incorporate memory mapped files into a task</li>
<li>Performance comparrisons</li>
</ul>
</li>
<li><a class="el" href="tutorial4.html">Tutorial 4</a> - Augmenting the graph from Tutorial 3a to use CUDA - [Source Code]()<ul>
<li>Sending data to/from the GPU with <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">htgs::ICudaTask</a></li>
<li>Techniques for data locality</li>
</ul>
</li>
<li>Tutorial 5 - Augmenting the graph from Tutorial 4 to use the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a> - [Source Code]()<ul>
<li>Scaling to multiple GPUs for matrix multiplication</li>
<li>Decomposition strategies to improve locality</li>
</ul>
</li>
<li>Tutorial 6a - Implementing Block LU Decomposition - [Source Code]()<ul>
<li>Methods for handling non-uniform computation</li>
<li>Understanding the effects of poor decomposition strategies</li>
</ul>
</li>
<li>Tutorial 6b - Implementing Block+Panel LU Decomposition - [Source Code] ()<ul>
<li>Methods for changing decomposition strategies</li>
<li>Analyzing the effects of good decomposition strategies</li>
</ul>
</li>
<li>Tutorial 7a - Augmenting the graph from Tutorial 6b to use CUDA - [Source Code]()<ul>
<li>Understanding the effects of locality and data motion</li>
</ul>
</li>
<li>Tutorial 7b - Incorporating advanced locality techniques to Tutorial 7a - [Source Code] ()<ul>
<li>Implementing a sliding window to improve locality</li>
<li>Effects of out-of-core computation on the GPU</li>
</ul>
</li>
<li>Tutorial8 - Augmenting the graph from Tutorial 7b to use <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a><ul>
<li>Scaling to multiple GPUs for LU Decomposition</li>
<li>Profiling to understand future improvements </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
