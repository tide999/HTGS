<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: Tutorial 2A</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial2a.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 2A </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut2a-objectives">Objectives </a></li>
<li class="level1"><a href="#tut2a-api-used">API Used </a></li>
<li class="level1"><a href="#tut2a-implementation">Implementation </a><ul><li class="level2"><a href="#tut2a-data">Data</a><ul><li class="level3"><a href="#tut2a-matrix-request">MatrixRequestData</a></li>
<li class="level3"><a href="#tut2a-matrix-data">MatrixBlockData</a></li>
<li class="level3"><a href="#tut2a-matrix-mul-data">MatrixBlockMulData</a></li>
<li class="level3"><a href="#tut2a-data-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut2a-tasks">Tasks</a><ul><li class="level3"><a href="#tut2a-gen-matrix-task">GenMatrixTask</a></li>
<li class="level3"><a href="#tut2a-hadamard-product-task">HadamardProductTask</a></li>
<li class="level3"><a href="#tut2a-task-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut2a-bookkeeper">Managing Dependencies with the Bookkeeper and IRule</a><ul><li class="level3"><a href="#tut2a-load-rule">HadamardLoadRule</a></li>
<li class="level3"><a href="#tut2a-bookkeeper-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut2a-create-and-execute-taskgraph">Creating and Executing the htgs::TaskGraphConf</a><ul><li class="level3"><a href="#tut2a-main-function">Main function (Hadamard Product)</a></li>
<li class="level3"><a href="#tut2a-taskgraph-notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#tut2a-summary">Summary </a></li>
</ul>
</div>
<div class="textblock"><p>In part A of this tutorial we introduce how to represent a dependency using the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> and <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a>.</p>
<p>The source code for the tutorial can be found at <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial2">Source Code</a>.</p>
<p>We have implemented a number of utility functions and tasks that are reused across the remaining tutorials, which can be viewed here: <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial-utils">utility functions</a> and <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial-utils/matrix-library">tasks</a>.</p>
<p>The algorithm we will be using for parts A and B of this tutorial is the <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">Hadamard product</a>, which is the product of elements of two matrices of equal size. There are two things to keep an eye out for in part A: (1) transforming an algorithm's representation to enable better pipelining and parallelism and (2) representing a dependency to ensure data is loaded prior to execution.</p>
<h1><a class="anchor" id="tut2a-objectives"></a>
Objectives </h1>
<ol type="1">
<li>How to encapsulate <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> objects</li>
<li>How to use local (per thread) variables in the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>How to exploit algorithm parallelism<ul>
<li>Transforming the algorithm into independent parts (i.e. block decomposition)</li>
<li>Creating thread pools based on compute needs</li>
</ul>
</li>
<li>How to provide a separation of concerns<ul>
<li>Separating matrix generation, computation, and dependencies.</li>
</ul>
</li>
<li>How to use the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> and <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> to manage dependencies</li>
</ol>
<h1><a class="anchor" id="tut2a-api-used"></a>
API Used </h1>
<ul>
<li>&lt;<a class="el" href="_i_data_8hpp.html" title="Implements the IData class, which is used for all data types entering/leaving a task graph...">htgs/api/IData.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_task_8hpp.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs/api/ITask.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_conf_8hpp.html" title="Implements the task graph configuration class responsible for managing ITask connections. ">htgs/api/TaskGraphConf.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_runtime_8hpp.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs/api/TaskGraphRuntime.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_bookkeeper_8hpp.html" title="Implements the Bookkeeper class. ">htgs/api/Bookkeeper.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_rule_8hpp.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs/api/IRule.hpp</a>&gt;</li>
</ul>
<h1><a class="anchor" id="tut2a-implementation"></a>
Implementation </h1>
<p>The first step in implementing any algorithm using HTGS is understanding how to exploit parallelism and methods for decomposing the problem into smaller pieces. This decomposition plays a role in how data is represented between tasks.</p>
<p>The Hadamard product algorithm is defined as <img class="formulaInl" alt="$A \circ B = C$" src="form_1.png"/>, which computes the element-wise product between two matrices that share the same dimensions.</p>
<p>Pseudo code: </p><div class="fragment"><div class="line">Given matrices A and B, each with the same dimensions</div><div class="line"></div><div class="line">for_each(row) {</div><div class="line">  for_each(col) {</div><div class="line">    C[row][col] = A[row][col] * B[row][col];</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>This algorithm is embarrassingly parallel, such that threads can process each element of the result matrix, C, in parallel without any need for synchronization. Therefore, providing a simple block decomposition, shown below, is sufficient for representing the data for the Hadamard Product. Picking the correct block size is of utmost importance to ensure the overhead of sending data between tasks in a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> does not overwhelm the computation. In addition, the block size can impact the locality within a task, such as ensuring data is reused within L1 cache and matches the vector processor instruction width. For the case of the Hadamard product, there is no data reuse within the task, so identifying a block size that improves utilization for the compute kernel is not important; however, in more complex algorithms, particularly algorithms with non-uniform computation (i.e. LU decomposition), picking the right block size can greatly impact utilization for various architectures.</p>
<div class="image">
<img src="hadamardProductFigure.png" alt="hadamardProductFigure.png"/>
<div class="caption">
Block decomposition of the Hadamard product</div></div>
<p> Below is a figure demonstrating the block decomposition of the Hadamard Product, which shows the impact of selecting block sizes. We see that there is overhead incurred when using small block sizes. This is attributed to data overwhelming the thread-safe FIFO queues and not enough computation per data element sent to the Hadamard product task. Increasing the block size improves the runtime, but if the block size becomes too large (such as the size of the entire matrix), then the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> does not benefit from pipelining.</p>
<div class="image">
<img src="blocksize-impact.png" alt="blocksize-impact.png"/>
<div class="caption">
Impact of block size for the Hadamard product</div></div>
<p>Given the block decomposition of the algorithm, we transform the Hadamard product into a dataflow graph and then into a task graph, shown below.</p>
<div class="image">
<img src="tut2Hadamard-dataflow.png" alt="tut2Hadamard-dataflow.png"/>
<div class="caption">
Hadamard product dataflow</div></div>
<p> <br />
 </p><div class="image">
<img src="tut2Hadamard-taskgraph.png" alt="tut2Hadamard-taskgraph.png"/>
<div class="caption">
Hadamard product task graph</div></div>
<p> For part A of this tutorial, we assume the data is generated in the <em>Read</em> task. In part B, we will incorporate Disk I/O to read from the disk.</p>
<p>The two read functions are merged into a single read task, and use a flag to indicate whether to read from matrix A or B. This step could easily be represented as two separate read tasks for matrices A and B. In this case, a preliminary <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> would be used to process the input of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> and distribute the incoming data between the two read tasks. This is due to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> only allowing a single task responsible for consuming data from the graph. In <a class="el" href="tutorial3a.html">tutorial3A</a>, we will demonstrate this concept.</p>
<p>Every task in this <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> can have one or more threads processing data. This allows the read task to pipeline with the Hadamard product task, overlapping the I/O of loading a matrix block with computing the Hadamard product of two blocks. In addition, separating these two components creates a separation between the I/O and computation. This way if a new I/O subsystem were to be used, then modifications can be done on that component without modifying the other tasks.</p>
<p>In the next sections, we implement each of the components for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<h2><a class="anchor" id="tut2a-data"></a>
Data</h2>
<p>Using the dataflow and task graphs, we analyze the various data requirements that need to be created for the input and output for each task.</p><ol type="1">
<li>Block requests data.<ul>
<li>Should request the row and column for a block of the matrix that is to be read.</li>
<li>Used by the <em>Read</em> task to specify which block to load</li>
</ul>
</li>
<li>Block matrix data<ul>
<li>Stores the row, column block and the actual matrix data</li>
<li>Used as output of the <em>Read</em> and <em>Hadamard Product</em> tasks</li>
</ul>
</li>
<li>Encapsulate two block matrix data<ul>
<li>Used to compute an operation between two matrices</li>
<li>Used as output from the <em>LoadRule</em> from the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a></li>
<li>Used as input for the <em>Hadamard Product</em> task</li>
</ul>
</li>
</ol>
<p>In this implementation, we use a variety of methods for encapsulating and reusing data objects. For example, the MatrixBlockData holds onto the MatrixRequestData. The MatrixBlockMulData, holds two instances of MatrixBlockData, one for matrix A and the other for matrix B. Encapsulating the data across objects that pass from task to task reduces code size, while holding onto the necessary metadata.</p>
<p>We also templatized the MatrixBlockData and MatrixBlockMulData to enable representing multiple types of data to further reduce code size.</p>
<p>These data classes also use the MatrixType enums, which can be found <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial-utils/enums">here</a>.</p>
<h3><a class="anchor" id="tut2a-matrix-request"></a>
MatrixRequestData</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../enums/MatrixType.h&quot;</span></div><div class="line"></div><div class="line"> <span class="keyword">class </span>MatrixRequestData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a> {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">   MatrixRequestData(<span class="keywordtype">size_t</span> row, <span class="keywordtype">size_t</span> col, MatrixType type) : row(row),        col(col), type(type) {}</div><div class="line"></div><div class="line">   <span class="keywordtype">size_t</span> getRow()<span class="keyword"> const </span>{</div><div class="line">     <span class="keywordflow">return</span> row;</div><div class="line">   }</div><div class="line">   <span class="keywordtype">size_t</span> getCol()<span class="keyword"> const </span>{</div><div class="line">     <span class="keywordflow">return</span> col;</div><div class="line">   }</div><div class="line">   MatrixType getType()<span class="keyword"> const </span>{</div><div class="line">     <span class="keywordflow">return</span> type;</div><div class="line">   }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">   <span class="keywordtype">size_t</span> row;</div><div class="line">   <span class="keywordtype">size_t</span> col;</div><div class="line">   MatrixType type;</div><div class="line"> };</div></div><!-- fragment --><h3><a class="anchor" id="tut2a-matrix-data"></a>
MatrixBlockData</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_memory_data_8hpp.html">htgs/api/MemoryData.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;MatrixRequestData.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>MatrixBlockData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a> {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  MatrixBlockData(<span class="keyword">const</span> std::shared_ptr&lt;MatrixRequestData&gt; &amp;request,</div><div class="line">                  <span class="keyword">const</span> Type &amp;matrixData,</div><div class="line">                  <span class="keywordtype">size_t</span> matrixWidth,</div><div class="line">                  <span class="keywordtype">size_t</span> matrixHeight,</div><div class="line">                  <span class="keywordtype">size_t</span> leadingDimension) :</div><div class="line">      request(request), matrixData(matrixData), matrixWidth(matrixWidth),       matrixHeight(matrixHeight), leadingDimension(leadingDimension) {}</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;MatrixRequestData&gt; &amp;getRequest()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> request;</div><div class="line">  }</div><div class="line">  <span class="keyword">const</span> Type &amp;getMatrixData()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixData;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">size_t</span> getMatrixWidth()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixWidth;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">size_t</span> getMatrixHeight()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixHeight;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> getLeadingDimension()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> leadingDimension;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::shared_ptr&lt;MatrixRequestData&gt; request;</div><div class="line">  Type matrixData;</div><div class="line">  <span class="keywordtype">size_t</span> matrixWidth;</div><div class="line">  <span class="keywordtype">size_t</span> matrixHeight;</div><div class="line">  <span class="keywordtype">size_t</span> leadingDimension;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut2a-matrix-mul-data"></a>
MatrixBlockMulData</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>MatrixBlockMulData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a> {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  MatrixBlockMulData(<span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; &amp;matrixA,</div><div class="line">                     <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; &amp;matrixB,</div><div class="line">                     <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; &amp;matrixC) :</div><div class="line">      matrixA(matrixA), matrixB(matrixB), matrixC(matrixC) {}</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; &amp;getMatrixA()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixA;</div><div class="line">  }</div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; &amp;getMatrixB()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixB;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; &amp;getMatrixC()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixC;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; matrixA;</div><div class="line">  std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; matrixB;</div><div class="line">  std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; matrixC;</div><div class="line">};</div></div><!-- fragment --> <h3><a class="anchor" id="tut2a-data-notes"></a>
Notes</h3>
<ul>
<li><a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> represents all data sent to/from tasks<ul>
<li>Can encapsulate multiple <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> objects into a single <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> object</li>
<li>Templatizing <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> for reuse</li>
</ul>
</li>
<li>Enums stored in <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> can be used to switch between various operations for an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>The matrix request, block, and block mul data objects are re-used for the remaining tutorials</li>
</ul>
<h2><a class="anchor" id="tut2a-tasks"></a>
Tasks</h2>
<p>From the tasks laid out in the above dataflow and task graphs, we define an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> for the Read and Hadamard product tasks.</p>
<p>In this example, we simplify the graph by generating the matrix rather than reading it from disk. As such, we have named the task to load the matrix as <em>GenMatrixTask</em>. In part B of this tutorial, we will incorporate loading the matrices from disk.</p>
<p>Each of the tasks within a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> have at least one thread responsible for executing their functionality. The <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask(size_t numThreads)</a> constructor is used to specify the number of threads for each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>. The <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a> uses this parameter to create copies of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> and bind each copy to a separate <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a>. Each <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a> shares the same input and output <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>, which have thread safe blocking queues. Therefore, when data enters a <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>, one of the htgs::TaskSchedulers waiting for that data will wake up and begin processing. This mechanism effectively increased the production and consumption rates for an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>.</p>
<p>The GenMatrixTask is used to decompose the matrix and generate the matrix data. Using the block size and the width and height of the full matrix, a sub region of the matrix is created. The task receives MatrixRequestData as input, which indicates which row/column block to generate. This data is filled into the output of the task using the <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa" title="Adds results to the output list to be sent to the next connected ITask in a TaskGraph. ">htgs::ITask::addResult</a> function.</p>
<p>The HadamardProductTask uses MatrixBlockMulData as input and applies the Hadamard product on the two blocks. The task assumes that the data is in the correct format and the matching row/column block is submitted for the task. Not having to worry about the state of the computation simplifies the design of the HadamardProductTask. A <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> is used to manage the state, which is stored within the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>, shown in the next section.</p>
<h3><a class="anchor" id="tut2a-gen-matrix-task"></a>
GenMatrixTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixRequestData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixBlockData.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>GenMatrixTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixRequestData, MatrixBlockData&lt;double *&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  GenMatrixTask(<span class="keywordtype">size_t</span> numThreads, <span class="keywordtype">size_t</span> blockSize, <span class="keywordtype">size_t</span> fullMatrixWidth, <span class="keywordtype">size_t</span> fullMatrixHeight) :</div><div class="line">      ITask(numThreads), blockSize(blockSize), fullMatrixHeight(fullMatrixHeight), fullMatrixWidth(fullMatrixWidth) {</div><div class="line">    numBlocksRows = (size_t) ceil((<span class="keywordtype">double</span>) fullMatrixHeight / (double) blockSize);</div><div class="line">    numBlocksCols = (size_t) ceil((<span class="keywordtype">double</span>) fullMatrixWidth / (double) blockSize);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixRequestData&gt; data)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordtype">size_t</span> row = data-&gt;getRow();</div><div class="line">    <span class="keywordtype">size_t</span> col = data-&gt;getCol();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> matrixWidth;</div><div class="line">    <span class="keywordtype">size_t</span> matrixHeight;</div><div class="line"></div><div class="line">    <span class="comment">// adjusts the matrix-block width to the appropriate size if it is considering the block at the very edge</span></div><div class="line">    <span class="keywordflow">if</span> (col == numBlocksCols - 1 &amp;&amp; fullMatrixWidth % blockSize != 0)</div><div class="line">      matrixWidth = fullMatrixWidth % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixWidth = blockSize;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (row == numBlocksRows - 1 &amp;&amp; fullMatrixHeight % blockSize != 0)</div><div class="line">      matrixHeight = fullMatrixHeight % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixHeight = blockSize;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate matrix Memory</span></div><div class="line">    <span class="keywordtype">double</span> *matrixData = <span class="keyword">new</span> <span class="keywordtype">double</span>[matrixHeight * matrixWidth];</div><div class="line"></div><div class="line">    <span class="comment">// Initialize with a simple value</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; matrixWidth * matrixHeight; i++)</div><div class="line">      matrixData[i] = 2.0;</div><div class="line"></div><div class="line">    this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;double *&gt;(data, matrixData, matrixWidth, matrixHeight, matrixWidth));</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;GenMatrixTask&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask&lt;MatrixRequestData, MatrixBlockData&lt;double *&gt;</a>&gt; *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> GenMatrixTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>(), blockSize, fullMatrixWidth, fullMatrixHeight);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> getNumBlocksRows()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksRows;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">size_t</span> getNumBlocksCols()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksCols;</div><div class="line">  }</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">size_t</span> blockSize;</div><div class="line">  <span class="keywordtype">size_t</span> fullMatrixWidth;</div><div class="line">  <span class="keywordtype">size_t</span> fullMatrixHeight;</div><div class="line">  <span class="keywordtype">size_t</span> numBlocksRows;</div><div class="line">  <span class="keywordtype">size_t</span> numBlocksCols;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut2a-hadamard-product-task"></a>
HadamardProductTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockMulData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>HadamardProductTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixBlockMulData&lt;double *&gt;, MatrixBlockData&lt;double *&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  HadamardProductTask(<span class="keywordtype">size_t</span> numThreads) : ITask(numThreads) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~HadamardProductTask() {  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixBlockMulData&lt;double *&gt;&gt; data)<span class="keyword"> override </span>{</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matAData = data-&gt;getMatrixA();</div><div class="line">    <span class="keyword">auto</span> matBData = data-&gt;getMatrixB();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *matrixA = matAData-&gt;getMatrixData();</div><div class="line">    <span class="keywordtype">double</span> *matrixB = matBData-&gt;getMatrixData();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> width = matAData-&gt;getMatrixWidth();</div><div class="line">    <span class="keywordtype">size_t</span> height = matAData-&gt;getMatrixHeight();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *result = <span class="keyword">new</span> <span class="keywordtype">double</span>[width * height];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; matAData-&gt;getMatrixWidth() * matAData-&gt;getMatrixHeight(); i++) {</div><div class="line">      result[i] = matrixA[i] * matrixB[i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> []matrixA;</div><div class="line">    matrixA = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> []matrixB;</div><div class="line">    matrixB = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matRequest = matAData-&gt;getRequest();</div><div class="line"></div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt;</div><div class="line">        matReq(<span class="keyword">new</span> MatrixRequestData(matRequest-&gt;getRow(), matRequest-&gt;getCol(), MatrixType::MatrixC));</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;double *&gt;(matReq, result, width, height, width));</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;HadamardProductTask&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> HadamardProductTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> HadamardProductTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --> <h3><a class="anchor" id="tut2a-task-notes"></a>
Notes</h3>
<ul>
<li>Specify a pool of threads for an ITask using the ITask(numThreads) constructor</li>
<li>Typically a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> purely handles computation and leaves state maintenance to the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a></li>
<li>Separating the matrix generation and computation allows for overlapping I/O with computation, particularly if the I/O comes from disk</li>
<li>The body of the copy() function should contain any information neccessary to pass on to another thread. In the case of the HadamardProductTask, it is only the number of threads.</li>
</ul>
<h2><a class="anchor" id="tut2a-bookkeeper"></a>
Managing Dependencies with the Bookkeeper and IRule</h2>
<p>The <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> is an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> that is defined within the HTGS API. It is used to manage dependencies, as well as provide a mechanism for outputting across multiple edges from a single task. Each edge from a Bookkeeper is managed by the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a>, which can have different output data types and decides when to produce data along its edge. The <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> implements this functionality by using a list of htgs::RuleManagers. When data enters a bookkeeper, the data is passed to each <a class="el" href="classhtgs_1_1_rule_manager.html" title="Connects a Bookkeeper to another ITask using one or more IRule(s). ">htgs::RuleManager</a>. The <a class="el" href="classhtgs_1_1_rule_manager.html" title="Connects a Bookkeeper to another ITask using one or more IRule(s). ">htgs::RuleManager</a> is attached to a consumer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> which will process the output data of the <a class="el" href="classhtgs_1_1_rule_manager.html" title="Connects a Bookkeeper to another ITask using one or more IRule(s). ">htgs::RuleManager</a>. The <a class="el" href="classhtgs_1_1_rule_manager.html" title="Connects a Bookkeeper to another ITask using one or more IRule(s). ">htgs::RuleManager</a> holds onto a single <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a>, which are used to update the state of the computation and produce data for the consumer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>. Each <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> is synchronously accessed using a mutex, such that when an <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> is processing data it is guaranteed that there will be only one thread at a time processing that rule. This attribute allows for the same <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> instance be safely shared among multiple Bookkeepers and RuleManagers. This is particularly important for the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a>, which will create a copy of an entire TaskGraph. We will demonstrate the functionality of ExecutionPipelines in a later tutorial.</p>
<p>Below is a diagram outlining the functionality of the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> ITask.</p>
<div class="image">
<img src="taskBookkeeper-v2.png" alt="taskBookkeeper-v2.png"/>
<div class="caption">
htgs::Bookkeeper htgs::ITask</div></div>
<p> To use the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a>, an <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> must be defined. The <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> represents a rule that processes input and decides when to pass data to an ITask. For the Hadamard product algorithm, we create the HadamardLoadRule to determine when a matching row, column block for both matrices A and B have been loaded, which is based upon the dependency for the HadamardProductTask. When the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> has received two blocks of data from MatrixA and MatrixB with a matching row/columng, then the dependency is satisfied. The <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> will then produce MatrixBlockMulData for the Hadamard task.</p>
<p>The <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> has an input and output type. The input type must match the htgs::Bookeeper type and the output type must match the input type of the consumer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>.</p>
<p>There are three virtual functions that define the behavior for each IRule:</p>
<ol type="1">
<li><a class="el" href="classhtgs_1_1_i_rule.html#acf7da2e1b9b25fce31a4dedb34d0df94" title="Virtual function to determine if a rule is ready to be terminated. ">htgs::IRule::canTerminateRule</a><ul>
<li>Determines if the rule is terminated or not.</li>
<li>The rule will automatically terminate if the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> is no longer receiving data from its input <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a></li>
<li>Can be used to determine when to end a cycle within a graph, which will be shown in Tutorial 3</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html#ab4ce46ea03c5c21db97eb51ae42dbe1b" title="Virtual function that handles when a rule is being shutdown for a particular pipelineId. ">htgs::IRule::shutdownRule</a><ul>
<li>Called when the IRule is terminating.</li>
<li>Use with care for deallocating the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a>'s local memory as the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a>'s instance may be shared within a <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a></li>
<li>It is safer to use the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> destructor to release memory</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4" title="Pure virtual function to process input data. ">htgs::IRule::applyRule</a><ul>
<li>Applies the rule on input data. (updates state)</li>
<li>To add data to the consumer ITask attached to the rule, use <a class="el" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2" title="Adds a result value to the output. ">htgs::IRule::addResult</a>.</li>
</ul>
</li>
</ol>
<p>To aid in managing the state of computation, the IRule class has helper functions to allocate a <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a>. The StateContainer is a templatized class that stores a one or two dimensional array of data. The class contains three functions for checking, updating, and fetching the data: has, set, and get, respectively.</p>
<ol type="1">
<li><a class="el" href="classhtgs_1_1_state_container.html#a609981818b06bc5f78d8eb9bdee6b59f" title="Checks whether the specified row column has data. ">htgs::StateContainer::has</a><ul>
<li>Checks whether data exists at a location or not.</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_state_container.html#aeda66d91101863ccba5b1d89b3632c53" title="Sets a value (by reference) at a row column. ">htgs::StateContainer::set</a><ul>
<li>Stores data at the specified location within the container</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_state_container.html#ab9531452c38416cca875e27686e3dd20" title="Gets a value from a row column. ">htgs::StateContainer::get</a><ul>
<li>Retrieve the data stored within the container</li>
</ul>
</li>
</ol>
<p>The HadamardLoadRule uses the StateContainer to store each MatrixBlockData that is generated from the GenMatrixTask. This container acts as a mechanism to store the state of the computation. When a MatrixBlockData has arrived that satisfies the Hadamard's dependency, then the HadamardLoadRule will generate output data for the HadamardProductTask. The <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a> is used to retrieve the MatrixBlockData that is used for the HadamardProductTask.</p>
<h3><a class="anchor" id="tut2a-load-rule"></a>
HadamardLoadRule</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_rule_8hpp.html">htgs/api/IRule.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockMulData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixRequestData.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>HadamardLoadRule : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_rule.html">htgs::IRule</a>&lt;MatrixBlockData&lt;Type&gt;, MatrixBlockMulData&lt;Type&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  HadamardLoadRule(<span class="keywordtype">size_t</span> blockWidth, <span class="keywordtype">size_t</span> blockHeight) {</div><div class="line">    this-&gt;matrixAState = this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#a8baa4e2f1a4126d21fe20ca378a5a72b">allocStateContainer</a>(blockHeight, blockWidth);</div><div class="line">    this-&gt;matrixBState = this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#a8baa4e2f1a4126d21fe20ca378a5a72b">allocStateContainer</a>(blockHeight, blockWidth);</div><div class="line">  }</div><div class="line"></div><div class="line">  ~HadamardLoadRule()<span class="keyword"> override </span>{</div><div class="line">    <span class="keyword">delete</span> matrixAState;</div><div class="line">    <span class="keyword">delete</span> matrixBState;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4">applyRule</a>(std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; data, <span class="keywordtype">size_t</span> pipelineId)<span class="keyword"> override </span>{</div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt; request = data-&gt;getRequest();</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (request-&gt;getType()) {</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixA:</div><div class="line">        this-&gt;matrixAState-&gt;set(request-&gt;getRow(), request-&gt;getCol(), data);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (this-&gt;matrixBState-&gt;has(request-&gt;getRow(), request-&gt;getCol())) {</div><div class="line">          this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a>(<span class="keyword">new</span> MatrixBlockMulData&lt;Type&gt;(data, this-&gt;matrixBState-&gt;get(request-&gt;getRow(), request-&gt;getCol()), <span class="keyword">nullptr</span>));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixB:</div><div class="line">        this-&gt;matrixBState-&gt;set(request-&gt;getRow(), request-&gt;getCol(), data);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (this-&gt;matrixAState-&gt;has(request-&gt;getRow(), request-&gt;getCol())) {</div><div class="line">          this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a>(<span class="keyword">new</span> MatrixBlockMulData&lt;Type&gt;(this-&gt;matrixAState-&gt;get(request-&gt;getRow(), request-&gt;getCol()), data, <span class="keyword">nullptr</span>));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixC:<span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixAny:<span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::string <a class="code" href="classhtgs_1_1_i_rule.html#a148fee616c01f057ddc522f2bf6a8b20">getName</a>()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;HadamardLoadRule&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;</a>&gt;&gt; *matrixAState;</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;</a>&gt;&gt; *matrixBState;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut2a-bookkeeper-notes"></a>
Notes</h3>
<ul>
<li>The <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> is an ITask defined by the HTGS API that manages depedencies between one or more consumer ITasks.</li>
<li>The <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> defines the connection between a <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> and a consumer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>.<ul>
<li>Each <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> can have multiple IRules</li>
</ul>
</li>
<li>The <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> input type must match the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> type, and the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> output type must match the consumer ITask's input type</li>
<li>A <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> creates a mutex to ensure that <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> is accessed synchronously</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2" title="Adds a result value to the output. ">htgs::IRule::addResult</a> is used within <a class="el" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4" title="Pure virtual function to process input data. ">htgs::IRule::applyRule</a> to pass data to the IRule's consumer task</li>
<li>The <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a> can be used to help manage the state of computation for input data or other types of state data</li>
</ul>
<h2><a class="anchor" id="tut2a-create-and-execute-taskgraph"></a>
Creating and Executing the htgs::TaskGraphConf</h2>
<p>As shown in Tutorial1, we use the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> to build and connect all our components that can then be executed using threads.</p>
<p>Adding edges is done using the functions presented in Tutorial1, to add a <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> to a graph, we use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">htgs::TaskGraphConf::addRuleEdge</a> function. This requires the creation of a <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a>, the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> consumer task, and the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> that produces data for the consumer. There are two variants of the <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">htgs::TaskGraphConf::addRuleEdge</a>; (1) allocate the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> using a std::shared_ptr, and (2) allocate the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> without a std::shared_ptr. Either version can be used; however, if the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> is to be shared among multiple htgs:Bookkeepers, then the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> must be wrapped into a std::shareD_ptr prior to adding it to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<p>Belows is the source code implementation for setup, construction of the task TaskGraph, executing the TaskGraph, and processing the output of the TaskGraph.</p>
<p>We use the SimpleClock implementation from the <a href="https://github.com/usnistgov/HTGS-Tutorials/blob/master/tutorial-utils/SimpleClock.h">Tutorial Utility Functions</a> to measure the execution time.</p>
<p>The traversal order with operating on matrices A and B for the Hadamard product is defined using the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef" title="Produces data for the input of the TaskGraph. ">htgs::TaskGraphConf::produceData</a> function. The graph processes this data in a first in, first out (FIFO) ordering, which can be switched to a priority queue by defining the directive USE_PRIORITY_QUEUE. In this implementation we produce a request for A and B immediately for each row, column pair within the same loop. This ensures that the Hadamard product computation is initiated as quickly as possible from the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a>. If this structure were to change to first iterate through requests for matrix A, followed by requests for matrix B in an entirely separate loop, then the requests for A would have to be fully processed prior to initiating the first computation on the Hadamard product.</p>
<h3><a class="anchor" id="tut2a-main-function"></a>
Main function (Hadamard Product)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_conf_8hpp.html">htgs/api/TaskGraphConf.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_runtime_8hpp.html">htgs/api/TaskGraphRuntime.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../tutorial-utils/matrix-library/tasks/GenMatrixTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../tutorial-utils/SimpleClock.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/HadamardProductTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rules/HadamardLoadRule.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> width = 1024;</div><div class="line">  <span class="keywordtype">size_t</span> height = 1024;</div><div class="line">  <span class="keywordtype">size_t</span> blockSize = 256;</div><div class="line">  <span class="keywordtype">size_t</span> numReadThreads = 4;</div><div class="line">  <span class="keywordtype">size_t</span> numProdThreads = 4;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> numRetry = 1;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> arg = 1; arg &lt; argc; arg++) {</div><div class="line">    std::string argvs(argv[arg]);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--width&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      width = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--height&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      height = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--block-size&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      blockSize = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--num-readers&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      numReadThreads = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--num-workers&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      numProdThreads = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--help&quot;</span>) {</div><div class="line">      std::cout &lt;&lt; argv[0]</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; help: [--width &lt;#&gt;] [--height &lt;#&gt;] [--block-size &lt;#&gt;] [--num-readers &lt;#&gt;] [--num-workers &lt;#&gt;] [--help]&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      exit(0);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  SimpleClock clk;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numRetry; i++) {</div><div class="line">    GenMatrixTask *genMatTask = <span class="keyword">new</span> GenMatrixTask(numReadThreads, blockSize, width, height);</div><div class="line">    HadamardProductTask *prodTask = <span class="keyword">new</span> HadamardProductTask(numProdThreads);</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> numBlocksCols = genMatTask-&gt;getNumBlocksCols();</div><div class="line">    <span class="keywordtype">size_t</span> numBlocksRows = genMatTask-&gt;getNumBlocksRows();</div><div class="line"></div><div class="line">    HadamardLoadRule&lt;double *&gt; *loadRule = <span class="keyword">new</span> HadamardLoadRule&lt;double *&gt;(numBlocksCols, numBlocksRows);</div><div class="line">    <span class="keyword">auto</span> bookkeeper = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&lt;double *&gt;</a>&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixRequestData, MatrixBlockData&lt;double *&gt;</a>&gt;();</div><div class="line"></div><div class="line">    taskGraph-&gt;setGraphConsumerTask(genMatTask);</div><div class="line">    taskGraph-&gt;addEdge(genMatTask, bookkeeper);</div><div class="line">    taskGraph-&gt;addRuleEdge(bookkeeper, loadRule, prodTask);</div><div class="line">    taskGraph-&gt;addGraphProducerTask(prodTask);</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a> *runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a>(taskGraph);</div><div class="line"></div><div class="line">    clk.start();</div><div class="line"></div><div class="line">    runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9">executeRuntime</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; numBlocksRows; row++) {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; numBlocksCols; col++) {</div><div class="line">        MatrixRequestData *matrixA = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixA);</div><div class="line">        MatrixRequestData *matrixB = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixB);</div><div class="line"></div><div class="line">        taskGraph-&gt;produceData(matrixA);</div><div class="line">        taskGraph-&gt;produceData(matrixB);</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    taskGraph-&gt;finishedProducingData();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!taskGraph-&gt;isOutputTerminated()) {</div><div class="line">      <span class="keyword">auto</span> data = taskGraph-&gt;consumeData();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (data != <span class="keyword">nullptr</span>) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Result received: &quot;</span> &lt;&lt; data-&gt;getRequest()-&gt;getRow() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; data-&gt;getRequest()-&gt;getCol() &lt;&lt; std::endl;</div><div class="line">        <span class="keywordtype">double</span> *mem = data-&gt;getMatrixData();</div><div class="line">        <span class="keyword">delete</span>[] mem;</div><div class="line">        mem = <span class="keyword">nullptr</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    }</div><div class="line">    runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a8f2eaf040695178b6f61db7b0ee16c89">waitForRuntime</a>();</div><div class="line"></div><div class="line">    clk.stopAndIncrement();</div><div class="line">    <span class="keyword">delete</span> runtime;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">&quot;, height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;, blocksize: &quot;</span> &lt;&lt; blockSize &lt;&lt; <span class="stringliteral">&quot;, average time: &quot;</span></div><div class="line">            &lt;&lt; clk.getAverageTime(TimeVal::MILLI) &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Sample execution: </p><div class="fragment"><div class="line">./tutorial2</div><div class="line">Result received: 0, 1</div><div class="line">Result received: 0, 0</div><div class="line">Result received: 1, 0</div><div class="line">Result received: 1, 1</div><div class="line">Result received: 0, 2</div><div class="line">Result received: 0, 3</div><div class="line">Result received: 1, 2</div><div class="line">Result received: 1, 3</div><div class="line">Result received: 2, 0</div><div class="line">Result received: 2, 1</div><div class="line">Result received: 2, 2</div><div class="line">Result received: 3, 0</div><div class="line">Result received: 2, 3</div><div class="line">Result received: 3, 2</div><div class="line">Result received: 3, 3</div><div class="line">Result received: 3, 1</div><div class="line">width: 1024, height: 1024, blocksize: 256, average time: 5.93778 ms</div></div><!-- fragment --><h3><a class="anchor" id="tut2a-taskgraph-notes"></a>
Notes</h3>
<ul>
<li>The <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">htgs::TaskGraphConf::addRuleEdge</a> is used to add an <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> to a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a><ul>
<li>Manages dependencies</li>
<li>Determines when data is sent to a consumer ITask.</li>
</ul>
</li>
<li>Control the traversal of data sent to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> for execution<ul>
<li>Customizes the order in which the htgs:ITask operates on data</li>
<li>Can be used to optimize data reuse, shown in Tutorial 3</li>
</ul>
</li>
<li>Having multiple threads computing the Hadamard product outputs the results in a non-deterministic ordering<ul>
<li>Enabling the directive USE_PRIORITY_QUEUE enables prioritization of data to satisfy specific ordering</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="tut2a-summary"></a>
Summary </h1>
<p>In this tutorial, we looked at parallelism/pipelining and handling dependencies.</p><ul>
<li>A method for representing an algorithm to maximize pipelining and parallelism</li>
<li>More advanced methods for representing <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a></li>
<li>How to specify a pool of threads for an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>The functions needed to define a dependency using <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a></li>
</ul>
<p>In <a class="el" href="tutorial2b.html">part B of Tutorial 2</a>, we augment the graph presented in this Tutorial to read matrices from disk. We also include the use of memory managers to throttle the graph, ensuring that memory limits are satisfied.</p>
<p>Additional information:</p><ul>
<li>Generating the dot file using <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a> after executing a TaskGraph will create a dot file that visualizes all of the threading that takes place within the htgs::Runtime. Add the PROFILE directive, and the dot file nodes can be color coded based on runtime, wait time, or maximum queue size for the <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
