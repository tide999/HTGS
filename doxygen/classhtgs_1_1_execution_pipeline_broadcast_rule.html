<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: htgs::ExecutionPipelineBroadcastRule&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhtgs_1_1_execution_pipeline_broadcast_rule.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhtgs_1_1_execution_pipeline_broadcast_rule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">htgs::ExecutionPipelineBroadcastRule&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the default execution pipeline rule that is used if no other rule is specified for an execution pipeline.  
 <a href="classhtgs_1_1_execution_pipeline_broadcast_rule.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_execution_pipeline_broadcast_rule_8hpp_source.html">htgs/core/rules/ExecutionPipelineBroadcastRule.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for htgs::ExecutionPipelineBroadcastRule&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_execution_pipeline_broadcast_rule__inherit__graph.png" border="0" usemap="#htgs_1_1_execution_pipeline_broadcast_rule_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="htgs_1_1_execution_pipeline_broadcast_rule_3_01_t_01_4_inherit__map" id="htgs_1_1_execution_pipeline_broadcast_rule_3_01_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classhtgs_1_1_i_rule.html" title="{htgs::IRule\&lt; T, T \&gt;\n|&#45; output\l|+ IRule()\l+ IRule()\l+ ~IRule()\l+ canTerminateRule()\l+ shutdownRule()\l+ getName()\l+ applyRule()\l+ applyRuleFunction()\l+ addResult()\l+ addResult()\l+ allocStateContainer()\l+ allocStateContainer()\l+ allocStateContainer()\l+ allocStateContainer()\l}" alt="" coords="47,248,203,516"/>
<area shape="rect" id="node3" href="classhtgs_1_1_any_i_rule.html" title="Base class for an htgs::IRule. " alt="" coords="51,5,199,200"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for htgs::ExecutionPipelineBroadcastRule&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_execution_pipeline_broadcast_rule__coll__graph.png" border="0" usemap="#htgs_1_1_execution_pipeline_broadcast_rule_3_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="htgs_1_1_execution_pipeline_broadcast_rule_3_01_t_01_4_coll__map" id="htgs_1_1_execution_pipeline_broadcast_rule_3_01_t_01_4_coll__map">
<area shape="rect" id="node2" href="classhtgs_1_1_i_rule.html" title="{htgs::IRule\&lt; T, T \&gt;\n||+ IRule()\l+ IRule()\l+ ~IRule()\l+ canTerminateRule()\l+ shutdownRule()\l+ getName()\l+ applyRule()\l+ applyRuleFunction()\l+ addResult()\l+ addResult()\l+ allocStateContainer()\l+ allocStateContainer()\l+ allocStateContainer()\l+ allocStateContainer()\l}" alt="" coords="85,263,241,531"/>
<area shape="rect" id="node3" href="classhtgs_1_1_any_i_rule.html" title="Base class for an htgs::IRule. " alt="" coords="5,5,153,200"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e44d724afb92829a3a11d451e00a2cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html#a3e44d724afb92829a3a11d451e00a2cd">canTerminateRule</a> (size_t pipelineId) override</td></tr>
<tr class="memdesc:a3e44d724afb92829a3a11d451e00a2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to determine if a rule is ready to be terminated.  <a href="#a3e44d724afb92829a3a11d451e00a2cd">More...</a><br /></td></tr>
<tr class="separator:a3e44d724afb92829a3a11d451e00a2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2319f3684d60923e69e353df5b0643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html#aca2319f3684d60923e69e353df5b0643">shutdownRule</a> (size_t pipelineId) override</td></tr>
<tr class="memdesc:aca2319f3684d60923e69e353df5b0643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that handles when a rule is being shutdown for a particular pipelineId.  <a href="#aca2319f3684d60923e69e353df5b0643">More...</a><br /></td></tr>
<tr class="separator:aca2319f3684d60923e69e353df5b0643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650d676f343c89b74f935309c05a3ea7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html#a650d676f343c89b74f935309c05a3ea7">getName</a> () override</td></tr>
<tr class="memdesc:a650d676f343c89b74f935309c05a3ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to get the name of the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a>.  <a href="#a650d676f343c89b74f935309c05a3ea7">More...</a><br /></td></tr>
<tr class="separator:a650d676f343c89b74f935309c05a3ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91adb1bf596ca637e0580e682cb0ea72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html#a91adb1bf596ca637e0580e682cb0ea72">applyRule</a> (std::shared_ptr&lt; T &gt; data, size_t pipelineId) override</td></tr>
<tr class="memdesc:a91adb1bf596ca637e0580e682cb0ea72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function to process input data.  <a href="#a91adb1bf596ca637e0580e682cb0ea72">More...</a><br /></td></tr>
<tr class="separator:a91adb1bf596ca637e0580e682cb0ea72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_i_rule"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_i_rule')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_i_rule.html">htgs::IRule&lt; T, T &gt;</a></td></tr>
<tr class="memitem:ad320c20c0d1b964983d90565c25bf74d inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top"><a id="ad320c20c0d1b964983d90565c25bf74d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#ad320c20c0d1b964983d90565c25bf74d">IRule</a> ()</td></tr>
<tr class="memdesc:ad320c20c0d1b964983d90565c25bf74d inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an IRule. <br /></td></tr>
<tr class="separator:ad320c20c0d1b964983d90565c25bf74d inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9232403502dc1248989b72416d2b98 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#abf9232403502dc1248989b72416d2b98">IRule</a> (bool <a class="el" href="classhtgs_1_1_any_i_rule.html#a964697be8e053c003436b7ec90b6a80d">useLocks</a>)</td></tr>
<tr class="memdesc:abf9232403502dc1248989b72416d2b98 inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an IRule with locks specified.  <a href="classhtgs_1_1_i_rule.html#abf9232403502dc1248989b72416d2b98">More...</a><br /></td></tr>
<tr class="separator:abf9232403502dc1248989b72416d2b98 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c2d0e1d683892cd9afc13fb73adbdf inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top"><a id="a07c2d0e1d683892cd9afc13fb73adbdf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#a07c2d0e1d683892cd9afc13fb73adbdf">~IRule</a> () override</td></tr>
<tr class="memdesc:a07c2d0e1d683892cd9afc13fb73adbdf inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a07c2d0e1d683892cd9afc13fb73adbdf inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49f147e7ab890a8a1f3f76db5a9b386 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::shared_ptr&lt; T &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#ac49f147e7ab890a8a1f3f76db5a9b386">applyRuleFunction</a> (std::shared_ptr&lt; T &gt; data, size_t pipelineId)</td></tr>
<tr class="memdesc:ac49f147e7ab890a8a1f3f76db5a9b386 inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the virtual rule function and processes output.  <a href="classhtgs_1_1_i_rule.html#ac49f147e7ab890a8a1f3f76db5a9b386">More...</a><br /></td></tr>
<tr class="separator:ac49f147e7ab890a8a1f3f76db5a9b386 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97407718736e3ee65417aecf9e79cc2 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a> (std::shared_ptr&lt; T &gt; result)</td></tr>
<tr class="memdesc:ab97407718736e3ee65417aecf9e79cc2 inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a result value to the output.  <a href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">More...</a><br /></td></tr>
<tr class="separator:ab97407718736e3ee65417aecf9e79cc2 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b62218b64549272aa6ef19e6b81b1fc inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#a5b62218b64549272aa6ef19e6b81b1fc">addResult</a> (T *result)</td></tr>
<tr class="memdesc:a5b62218b64549272aa6ef19e6b81b1fc inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a result value to the output.  <a href="classhtgs_1_1_i_rule.html#a5b62218b64549272aa6ef19e6b81b1fc">More...</a><br /></td></tr>
<tr class="separator:a5b62218b64549272aa6ef19e6b81b1fc inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baa4e2f1a4126d21fe20ca378a5a72b inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_state_container.html">StateContainer</a>&lt; std::shared_ptr&lt; T &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#a8baa4e2f1a4126d21fe20ca378a5a72b">allocStateContainer</a> (size_t height, size_t width)</td></tr>
<tr class="memdesc:a8baa4e2f1a4126d21fe20ca378a5a72b inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a two dimensional state container using the input type of the IRule.  <a href="classhtgs_1_1_i_rule.html#a8baa4e2f1a4126d21fe20ca378a5a72b">More...</a><br /></td></tr>
<tr class="separator:a8baa4e2f1a4126d21fe20ca378a5a72b inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e10944b079f2daf485932f7b5f3e543 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_state_container.html">StateContainer</a>&lt; V &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#a1e10944b079f2daf485932f7b5f3e543">allocStateContainer</a> (size_t height, size_t width, V defaultValue)</td></tr>
<tr class="memdesc:a1e10944b079f2daf485932f7b5f3e543 inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a two dimensional state container using the template argument.  <a href="classhtgs_1_1_i_rule.html#a1e10944b079f2daf485932f7b5f3e543">More...</a><br /></td></tr>
<tr class="separator:a1e10944b079f2daf485932f7b5f3e543 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73afffa52923f366895d995f48a10cb4 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_state_container.html">StateContainer</a>&lt; std::shared_ptr&lt; T &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#a73afffa52923f366895d995f48a10cb4">allocStateContainer</a> (size_t size)</td></tr>
<tr class="memdesc:a73afffa52923f366895d995f48a10cb4 inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a one dimensional state container using the input type of the IRule.  <a href="classhtgs_1_1_i_rule.html#a73afffa52923f366895d995f48a10cb4">More...</a><br /></td></tr>
<tr class="separator:a73afffa52923f366895d995f48a10cb4 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f403fbafa677f71e09c61496b44c7a4 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_state_container.html">StateContainer</a>&lt; V &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_rule.html#a3f403fbafa677f71e09c61496b44c7a4">allocStateContainer</a> (size_t size, V defaultValue)</td></tr>
<tr class="memdesc:a3f403fbafa677f71e09c61496b44c7a4 inherit pub_methods_classhtgs_1_1_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a one dimensional state container using the input type of the IRule.  <a href="classhtgs_1_1_i_rule.html#a3f403fbafa677f71e09c61496b44c7a4">More...</a><br /></td></tr>
<tr class="separator:a3f403fbafa677f71e09c61496b44c7a4 inherit pub_methods_classhtgs_1_1_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_any_i_rule"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_any_i_rule')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_any_i_rule.html">htgs::AnyIRule</a></td></tr>
<tr class="memitem:a3798cf5504b6c2e2a81da3f1a12dca82 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memItemLeft" align="right" valign="top"><a id="a3798cf5504b6c2e2a81da3f1a12dca82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_rule.html#a3798cf5504b6c2e2a81da3f1a12dca82">AnyIRule</a> ()</td></tr>
<tr class="memdesc:a3798cf5504b6c2e2a81da3f1a12dca82 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classhtgs_1_1_any_i_rule.html" title="Base class for an htgs::IRule. ">AnyIRule</a> with locks enabled. <br /></td></tr>
<tr class="separator:a3798cf5504b6c2e2a81da3f1a12dca82 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec2877c0bbe8b85d844516b9b3df88b inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_rule.html#a2ec2877c0bbe8b85d844516b9b3df88b">AnyIRule</a> (bool <a class="el" href="classhtgs_1_1_any_i_rule.html#a964697be8e053c003436b7ec90b6a80d">useLocks</a>)</td></tr>
<tr class="memdesc:a2ec2877c0bbe8b85d844516b9b3df88b inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classhtgs_1_1_any_i_rule.html" title="Base class for an htgs::IRule. ">AnyIRule</a> with locks specified.  <a href="classhtgs_1_1_any_i_rule.html#a2ec2877c0bbe8b85d844516b9b3df88b">More...</a><br /></td></tr>
<tr class="separator:a2ec2877c0bbe8b85d844516b9b3df88b inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7864e681bf3bb57b745d06e29e737a inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memItemLeft" align="right" valign="top"><a id="a7d7864e681bf3bb57b745d06e29e737a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_rule.html#a7d7864e681bf3bb57b745d06e29e737a">~AnyIRule</a> ()</td></tr>
<tr class="memdesc:a7d7864e681bf3bb57b745d06e29e737a inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a7d7864e681bf3bb57b745d06e29e737a inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2e5f53eb84cbb613e4bca6fe16f571 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memItemLeft" align="right" valign="top">std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_rule.html#abc2e5f53eb84cbb613e4bca6fe16f571">getMutex</a> ()</td></tr>
<tr class="memdesc:abc2e5f53eb84cbb613e4bca6fe16f571 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mutex associated with this <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a>.  <a href="classhtgs_1_1_any_i_rule.html#abc2e5f53eb84cbb613e4bca6fe16f571">More...</a><br /></td></tr>
<tr class="separator:abc2e5f53eb84cbb613e4bca6fe16f571 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005df6de057d052110a9ca38ebd7a483 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_rule.html#a005df6de057d052110a9ca38ebd7a483">canUseLocks</a> () const</td></tr>
<tr class="memdesc:a005df6de057d052110a9ca38ebd7a483 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the rule should use locks or not.  <a href="classhtgs_1_1_any_i_rule.html#a005df6de057d052110a9ca38ebd7a483">More...</a><br /></td></tr>
<tr class="separator:a005df6de057d052110a9ca38ebd7a483 inherit pub_methods_classhtgs_1_1_any_i_rule"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class htgs::ExecutionPipelineBroadcastRule&lt; T &gt;</h3>

<p>the default execution pipeline rule that is used if no other rule is specified for an execution pipeline. </p>
<p>When constructing an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> task, rules must be added to the task to indicate how data is distributed within pipelines. If no rule is specified, then this rule is added automatically during initialization of the task.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input/output type for the rule, must be of type <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a91adb1bf596ca637e0580e682cb0ea72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91adb1bf596ca637e0580e682cb0ea72">&#9670;&nbsp;</a></span>applyRule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html">htgs::ExecutionPipelineBroadcastRule</a>&lt; T &gt;::applyRule </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function to process input data. </p>
<p>Use the addResult function to add values to the output edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">pipelineId</td><td>the pipelineId</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To send data to the next edge use addResult </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4">htgs::IRule&lt; T, T &gt;</a>.</p>

</div>
</div>
<a id="a3e44d724afb92829a3a11d451e00a2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e44d724afb92829a3a11d451e00a2cd">&#9670;&nbsp;</a></span>canTerminateRule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html">htgs::ExecutionPipelineBroadcastRule</a>&lt; T &gt;::canTerminateRule </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to determine if a rule is ready to be terminated. </p>
<p>If there is no more data entering the <a class="el" href="classhtgs_1_1_rule_manager.html" title="Connects a Bookkeeper to another ITask using one or more IRule(s). ">RuleManager</a> that is managing this <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a>, then the rule will be automatically terminated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipelineId associated with this rule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the rule should be terminated or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the rule should be terminated </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the rule should not be terminated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The rule will automatically be terminated if the input <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> has terminated. </dd>
<dd>
By default, this function returns false </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_rule.html#acf7da2e1b9b25fce31a4dedb34d0df94">htgs::IRule&lt; T, T &gt;</a>.</p>

</div>
</div>
<a id="a650d676f343c89b74f935309c05a3ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650d676f343c89b74f935309c05a3ea7">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html">htgs::ExecutionPipelineBroadcastRule</a>&lt; T &gt;::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to get the name of the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_rule.html#a148fee616c01f057ddc522f2bf6a8b20">htgs::IRule&lt; T, T &gt;</a>.</p>

</div>
</div>
<a id="aca2319f3684d60923e69e353df5b0643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2319f3684d60923e69e353df5b0643">&#9670;&nbsp;</a></span>shutdownRule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html">htgs::ExecutionPipelineBroadcastRule</a>&lt; T &gt;::shutdownRule </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that handles when a rule is being shutdown for a particular pipelineId. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipelineId to shutdown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can be used to release memory, but if there are multiple pipelines managed by an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a>, then the memory release should occur in a destructor. </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_rule.html#ab4ce46ea03c5c21db97eb51ae42dbe1b">htgs::IRule&lt; T, T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/tjb3/work/HTGS/src/htgs/core/rules/<a class="el" href="_execution_pipeline_broadcast_rule_8hpp_source.html">ExecutionPipelineBroadcastRule.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>htgs</b></li><li class="navelem"><a class="el" href="classhtgs_1_1_execution_pipeline_broadcast_rule.html">ExecutionPipelineBroadcastRule</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
