<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: Tutorial 4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 4 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut4-objectives">Objectives </a></li>
<li class="level1"><a href="#tut4-api-used">API Used </a></li>
<li class="level1"><a href="#tut4-implementation">Implementation </a><ul><li class="level2"><a href="#tut4-data">Data</a></li>
<li class="level2"><a href="#tut4-tasks">Tasks</a><ul><li class="level3"><a href="#tut4-load-matrix-task">LoadMatrixTask</a></li>
<li class="level3"><a href="#tut4-matmul-task">MatMulBlkTask</a></li>
<li class="level3"><a href="#tut4-matmul-accum-task">MatMulAccumTask</a></li>
<li class="level3"><a href="#tut4-matmul-output-task">MatMulOutputTask</a></li>
<li class="level3"><a href="#tut4-task-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut4-bookkeeper">Managing Dependencies with the Bookkeeper and IRule</a><ul><li class="level3"><a href="#tut4-distr-rule">MatMulDistributeRule</a></li>
<li class="level3"><a href="#tut4-load-rule">MatMulLoadRule</a></li>
<li class="level3"><a href="#tut4-acc-rule">MatMulAccumulateRule</a></li>
<li class="level3"><a href="#tut4-output-rule">MatMulOutputRule</a></li>
<li class="level3"><a href="#tut4-bookkeeper-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut4-create-and-execute-taskgraph">Creating and Executing the htgs::TaskGraphConf</a><ul><li class="level3"><a href="#tut4-main-function">Main function (Matrix Multiplication)</a></li>
<li class="level3"><a href="#tut4-taskgraph-notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#tut4-summary">Summary </a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we augment the matrix multiplication task graph from <a href="#tutorial3a">Tutorial3A</a> to include CUDA tasks to copy data to/from the GPU and execute matrix multiplication on the GPU. For this tutorial, we assume the data has been loaded into CPU memory, and HTGS will be responsible for copying data between address spaces.</p>
<p>Three important challenges with GPU programming are: 1) Effectively overlapping computation with data motion 2) Avoiding additional memory copies 3) Managing the limited amount of memory on GPUs</p>
<p>HTGS provides mechanisms for handling these challenges; (1) have separate tasks for data copying and computation, (2) use HTGS memory managers and specify a htgs:IMemoryReleaseRule to keep data on the GPU for as long as possible, and (3) use the HTGS memory manager to allocate a fixed size pool of memory based on the amount of memory available on the GPU.</p>
<p>The source code for this tutorial can be found <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial4">here</a></p>
<p>You will need to install the <a href="https://developer.nvidia.com/cuda-toolkit">NVIDIA</a> Toolkit to use CUDA.</p>
<h1><a class="anchor" id="tut4-objectives"></a>
Objectives </h1>
<ol type="1">
<li>How to augment an existing graph to utilize the GPU</li>
<li>How to overlap computation with data motion</li>
<li>How to analyze performance on the GPU, gflops and GB/s transfer rates.</li>
</ol>
<h1><a class="anchor" id="tut4-api-used"></a>
API Used </h1>
<ul>
<li>&lt;<a class="el" href="_i_cuda_task_8hpp.html" title="ICudaTask.hpp is used to define an NVIDIA Cuda GPU Tasks. ">htgs/api/ICudaTask.hpp</a>&gt;</li>
</ul>
<h1><a class="anchor" id="tut4-implementation"></a>
Implementation </h1>
<p>We use the same block-decomposition strategy as shown in tutorial3; however, to take into account limited memory and locality, we change the traversal pattern. Previously, we used an inner-product traversal to compute the matrix multiplication on the CPU.</p>
<div class="image">
<img src="matMulDecomp.png" alt="matMulDecomp.png"/>
<div class="caption">
Matrix multiplication block decomposition</div></div>
<p> This could be used in the GPU variant, but doing so would complicate memory usage, and for larger out-of-core problems, would require the GPU to reload multiple blocks. Instead, we switch to an outer-product traversal, shown below.</p>
<div class="image">
<img src="matMulOuterDecomp.png" alt="matMulOuterDecomp.png"/>
<div class="caption">
Matrix multiplication outer-product traversal</div></div>
<p> Using this type of traversal simplifies the memory rules for each block that is allocated on the GPU. If a block of matrix A at a specified row and column, then that block must be multiplied by the matching row of B, such that the column of A matches the row of B. Once all blocks have been multiplied between the block of A and row of B, then the block of A can be recycled and used later in the computation. The traversal order when requesting blocks of A and B enforces this pattern.</p>
<p>The graph for matrix multiplication from tutorial 3 is shown below.</p>
<div class="image">
<img src="matMulTaskGraphv2.png" alt="matMulTaskGraphv2.png"/>
<div class="caption">
Matrix multiplication task graph</div></div>
<p> We augment the graph to include CUDA tasks for copying from the CPU to the GPU, matrix multiplication, and copying back from the GPU to the CPU. The remaining tasks and rules can be reused. We add three memory edges for memory for matrices A, B, and sub-results of C. The reduction step with accumulating the sub-results of C are left to processing on the CPU.</p>
<h2><a class="anchor" id="tut4-data"></a>
Data</h2>
<p>This tutorial uses the same data as presented in <a class="el" href="tutorial2a.html#tut2a-data">Tutorial 2A Data</a>.</p>
<h2><a class="anchor" id="tut4-tasks"></a>
Tasks</h2>
<p>From the tasks laid out in the above dataflow and task graphs, we define a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> for the load, matrix multiplication (GEMM), accumulate, and write tasks. As mentioned above, we assume all matrices will fit into main memory, and the result matrix has been initialized to zeros.</p>
<p>The <a class="el" href="tutorial3a.html#tut3a-load-matrix-task">LoadMatrixTask</a> receives a pointer to a matrix from the main thread and the type (either matrix A or B). In the execute phase of the task, a request is received, which determines the sub-region of the matrix based on the block size. The purpose of this task is to create a pointer to the starting position of the block for a matrix at a given row,column block request. This pointer is sent to the next task with the necessary width, height, and leading dimension size of the block.</p>
<p>The <a class="el" href="tutorial3a.html#tut3a-matmul-task">MatMulBlkTask</a> receives MatrixBlockMulData. We use the <a href="https://github.com/usnistgov/HTGS-Tutorials/blob/master/tutorial-utils/matrix-library/operations/matmul.cpp">computeMatMul</a> function to process the matrix multiplication of two of the matrices from the input data. The sub-result is stored in a piece of memory that is dynamically allocated within the execute function, which is then send along the output edge using <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa" title="Adds results to the output list to be sent to the next connected ITask in a TaskGraph. ">htgs::ITask::addResult</a>.</p>
<p>The <a class="el" href="tutorial3a.html#tut3a-matmul-accum-task">MatMulAccumTask</a> receives MatrixBlockMulData to accumulate two of the matrices. One of the matrices is overwritten and sent as output for this task. The other matrix has its memory released.</p>
<p>The <a class="el" href="tutorial3a.html#tut3a-matmul-output-task">MatMulOutputTask</a> receives MatrixBlockData, which represents the final result for a block of the result matrix. The constructor for this task receives a pointer to a matrix that is used to store the final resulting matrix. The purpose of this task is to copy the block matrix into the larger matrix, which is used by the main thread to simplify validating that the result is correct. The task sends MAtrixRequestData along its output edge to indicate which row,column block has been processed.</p>
<h3><a class="anchor" id="tut4-load-matrix-task"></a>
LoadMatrixTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixRequestData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../util-matrix.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>LoadMatrixTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixRequestData, MatrixBlockData&lt;double *&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  LoadMatrixTask(<span class="keywordtype">double</span> *matrix, <span class="keywordtype">size_t</span> numThreads, MatrixType matrixType, <span class="keywordtype">size_t</span> blockSize, <span class="keywordtype">size_t</span> fullMatrixWidth, <span class="keywordtype">size_t</span> fullMatrixHeight, <span class="keywordtype">bool</span> colMajor) :</div><div class="line">      ITask(numThreads),</div><div class="line">      matrix(matrix),</div><div class="line">      blockSize(blockSize),</div><div class="line">      fullMatrixHeight(fullMatrixHeight),</div><div class="line">      fullMatrixWidth(fullMatrixWidth),</div><div class="line">      matrixType(matrixType),</div><div class="line">      colMajor(colMajor)</div><div class="line">  {</div><div class="line">    numBlocksRows = (size_t) ceil((<span class="keywordtype">double</span>) fullMatrixHeight / (double) blockSize);</div><div class="line">    numBlocksCols = (size_t) ceil((<span class="keywordtype">double</span>) fullMatrixWidth / (double) blockSize);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~LoadMatrixTask() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixRequestData&gt; data) {</div><div class="line">    <span class="keywordtype">size_t</span> row = data-&gt;getRow();</div><div class="line">    <span class="keywordtype">size_t</span> col = data-&gt;getCol();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> matrixWidth;</div><div class="line">    <span class="keywordtype">size_t</span> matrixHeight;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (col == numBlocksCols - 1 &amp;&amp; fullMatrixWidth % blockSize != 0)</div><div class="line">      matrixWidth = fullMatrixWidth % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixWidth = blockSize;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (row == numBlocksRows - 1 &amp;&amp; fullMatrixHeight % blockSize != 0)</div><div class="line">      matrixHeight = fullMatrixHeight % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixHeight = blockSize;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *memPtr;</div><div class="line"></div><div class="line">    <span class="comment">// compute starting location of pointer</span></div><div class="line">    <span class="keywordflow">if</span> (colMajor)</div><div class="line">      memPtr = &amp;matrix[IDX2C(blockSize*row, blockSize*col, fullMatrixHeight)];</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      memPtr = &amp;matrix[blockSize * col + blockSize * row * fullMatrixWidth];</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (colMajor)</div><div class="line">      <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;double *&gt;(data, memPtr, matrixWidth, matrixHeight, fullMatrixHeight));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;double *&gt;(data, memPtr, matrixWidth, matrixHeight, fullMatrixWidth));</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;LoadMatrixTask(&quot;</span> + matrixTypeToString(matrixType) + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> LoadMatrixTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> LoadMatrixTask(matrix, this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>(), matrixType, blockSize, fullMatrixWidth, fullMatrixHeight, colMajor);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> getNumBlocksRows()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksRows;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> getNumBlocksCols()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksCols;</div><div class="line">  }</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *matrix;</div><div class="line">  <span class="keywordtype">size_t</span> blockSize;</div><div class="line">  <span class="keywordtype">size_t</span> fullMatrixWidth;</div><div class="line">  <span class="keywordtype">size_t</span> fullMatrixHeight;</div><div class="line">  <span class="keywordtype">size_t</span> numBlocksRows;</div><div class="line">  <span class="keywordtype">size_t</span> numBlocksCols;</div><div class="line">  MatrixType matrixType;</div><div class="line">  <span class="keywordtype">bool</span> colMajor;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-matmul-task"></a>
MatMulBlkTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/operations/matmul.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockMulData.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MatMulBlkTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixBlockMulData&lt;double *&gt;, MatrixBlockData&lt;double *&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatMulBlkTask(<span class="keywordtype">size_t</span> numThreads, <span class="keywordtype">bool</span> colMajor) :</div><div class="line">      ITask(numThreads), colMajor(colMajor) {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixBlockMulData&lt;double *&gt;&gt; data) {</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matAData = data-&gt;getMatrixA();</div><div class="line">    <span class="keyword">auto</span> matBData = data-&gt;getMatrixB();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *matrixA = matAData-&gt;getMatrixData();</div><div class="line">    <span class="keywordtype">double</span> *matrixB = matBData-&gt;getMatrixData();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> width = matBData-&gt;getMatrixWidth();</div><div class="line">    <span class="keywordtype">size_t</span> height = matAData-&gt;getMatrixHeight();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> lda = matAData-&gt;getLeadingDimension();</div><div class="line">    <span class="keywordtype">size_t</span> ldb = matBData-&gt;getLeadingDimension();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> ldc;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (colMajor)</div><div class="line">      ldc = height;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      ldc = width;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *result = <span class="keyword">new</span> <span class="keywordtype">double</span>[width * height];</div><div class="line"></div><div class="line">    computeMatMul(height, width, matAData-&gt;getMatrixWidth(), 1.0, matrixA, lda,</div><div class="line">                  matrixB, ldb, 0.0, result, ldc, colMajor);</div><div class="line"></div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt; matReq(<span class="keyword">new</span> MatrixRequestData(matAData-&gt;getRequest()-&gt;getRow(),</div><div class="line">                                                                    matBData-&gt;getRequest()-&gt;getCol(),</div><div class="line">                                                                    MatrixType::MatrixC));</div><div class="line"></div><div class="line">    this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;double *&gt;(matReq, result, width, height, ldc));</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulBlkTask&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> MatMulBlkTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> MatMulBlkTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>(), colMajor);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">bool</span> colMajor;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-matmul-accum-task"></a>
MatMulAccumTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/util-matrix.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MatMulAccumTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixBlockMulData&lt;double *&gt;, MatrixBlockData&lt;double *&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatMulAccumTask(<span class="keywordtype">size_t</span> numThreads, <span class="keywordtype">bool</span> colMajor) : ITask(numThreads), colMajor(colMajor) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixBlockMulData&lt;double *&gt;&gt; data) {</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matAData = data-&gt;getMatrixA();</div><div class="line">    <span class="keyword">auto</span> matBData = data-&gt;getMatrixB();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *matrixA = matAData-&gt;getMatrixData();</div><div class="line">    <span class="keywordtype">double</span> *matrixB = matBData-&gt;getMatrixData();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> width = matAData-&gt;getMatrixWidth();</div><div class="line">    <span class="keywordtype">size_t</span> height = matAData-&gt;getMatrixHeight();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (colMajor)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; width; j++) {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; height; i++) {</div><div class="line">          matrixA[IDX2C(i, j, height)] = matrixA[IDX2C(i, j, height)]</div><div class="line">              + matrixB[IDX2C(i, j, height)];</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; height; i++) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; width; j++) {</div><div class="line">          matrixA[i * width + j] = matrixA[i * width + j] + matrixB[i * width + j];</div><div class="line">        }</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> []matrixB;</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(matAData);</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulAccumTask&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> MatMulAccumTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> MatMulAccumTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>(), colMajor);</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">bool</span> colMajor;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-matmul-output-task"></a>
MatMulOutputTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/util-filesystem.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/util-matrix.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MatMulOutputTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixBlockData&lt;double *&gt;, MatrixRequestData&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  MatMulOutputTask(<span class="keywordtype">double</span> *matrix, <span class="keywordtype">size_t</span> leadingDim, <span class="keywordtype">size_t</span> blockSize, <span class="keywordtype">bool</span> colMajor) :</div><div class="line">      matrix(matrix), leadingDim(leadingDim), blockSize(blockSize), colMajor(colMajor) { }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixBlockData&lt;double *&gt;&gt; data) {</div><div class="line">    <span class="keywordtype">size_t</span> col = data-&gt;getRequest()-&gt;getCol();</div><div class="line">    <span class="keywordtype">size_t</span> row = data-&gt;getRequest()-&gt;getRow();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *startLocation;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (colMajor)</div><div class="line">      startLocation = &amp;this-&gt;matrix[IDX2C(blockSize*row, blockSize*col, leadingDim)];</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      startLocation = &amp;this-&gt;matrix[blockSize * col + blockSize * row * leadingDim];</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> dataWidth = data-&gt;getMatrixWidth();</div><div class="line">    <span class="keywordtype">size_t</span> dataHeight = data-&gt;getMatrixHeight();</div><div class="line">    <span class="keywordtype">double</span> *matrixData = data-&gt;getMatrixData();</div><div class="line">    <span class="keywordflow">if</span> (colMajor)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; dataWidth; c++) {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> r = 0; r &lt; dataHeight; r++) {</div><div class="line">            startLocation[IDX2C(r, c, leadingDim)] = matrixData[IDX2C(r, c, data-&gt;getLeadingDimension())];</div><div class="line">        }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> r = 0; r &lt; dataHeight; r++) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; dataWidth; c++) {</div><div class="line">            startLocation[r * leadingDim + c] = matrixData[r * data-&gt;getLeadingDimension() + c];</div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">delete</span>[] matrixData;</div><div class="line">    matrixData = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(data-&gt;getRequest());</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulOutputTask&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> MatMulOutputTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> MatMulOutputTask(matrix, leadingDim, blockSize, colMajor);</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *matrix;</div><div class="line">  <span class="keywordtype">size_t</span> leadingDim;</div><div class="line">  <span class="keywordtype">size_t</span> blockSize;</div><div class="line">  <span class="keywordtype">bool</span> colMajor;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-task-notes"></a>
Notes</h3>
<ul>
<li>The constructor of a task can specify data that is modified within the task's execute function while also used by other tasks or the main thread<ul>
<li>The result matrix is used by the main thread and the output task</li>
</ul>
</li>
<li>Customizing how a task operates using parameters passed to the constructor<ul>
<li>Re-using the LoadMatrixTask to process either matrix A or B</li>
<li>Specifying column or row major ordering</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="tut4-bookkeeper"></a>
Managing Dependencies with the Bookkeeper and IRule</h2>
<p>The matrix multiplication HTGS task graph consists of four htgs::IRules.</p>
<ol type="1">
<li><a class="el" href="tutorial3a.html#tut3a-distr-rule">MatMulDistributeRule</a><ul>
<li>Processes the input for the graph to distribute data for matrices A and B between the load matrix tasks.</li>
<li>Two instances of this rule will be created, one for sending data for matrix A and the other for matrix B</li>
</ul>
</li>
<li><a class="el" href="tutorial3a.html#tut3a-load-rule">MatMulLoadRule</a><ul>
<li>Uses three <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a>; (1) matrix A state, (2) matrix B state, and (3) matrix C state<ul>
<li>Receives a matrix block and stores it in one of the matrix A or B state containers depending on the matrix type received</li>
<li>Next, checks along the appropriate row or column to see if any blocks are ready to begin processing the matrix multiplication.</li>
<li>Checks matrix C state to see if a matrix multiplication is in flight or not</li>
<li>If matrix C state is not in flight, then initates the matrix multiplication, and updates the matrix C state</li>
</ul>
</li>
<li>Allows for blocks to be received and processed correctly in any order.</li>
<li>Can use the debugging functions; <a class="el" href="classhtgs_1_1_state_container.html#abc89b5ac963dfd0a1e892169efe9aaa8" title="Prints the state of the state container. ">htgs::StateContainer::printState</a> and <a class="el" href="classhtgs_1_1_state_container.html#a375fd966071537133927f4be79e1ae9e" title="Prints the contents of the state container. ">htgs::StateContainer::printContents</a>, to view the state and contents within, respectively.</li>
</ul>
</li>
<li><a class="el" href="tutorial3a.html#tut3a-acc-rule">MatMulAccumulateRule</a><ul>
<li>Uses one <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a> to store partial results of the result matrix<ul>
<li>If the container has a row, column block, then that block is removed from the container and is sent to be accumulated with the data that was received</li>
<li>If the container does not have a row, column block, then the data that was received is stored</li>
</ul>
</li>
<li>Keeps track of a count, which represents the total number of blocks being accumulated<ul>
<li>Determine when all blocks have been accumulated, which terminates the cycle in the graph, checked in <a class="el" href="classhtgs_1_1_i_rule.html#acf7da2e1b9b25fce31a4dedb34d0df94" title="Virtual function to determine if a rule is ready to be terminated. ">htgs::IRule::canTerminateRule</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="tutorial3a.html#tut3a-output-rule">MatMulOutputRule</a><ul>
<li>Uses one <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a> to keep track of a count for each row, column within the result matrix<ul>
<li>The row, column of the received data increments the appropriate count by one</li>
<li>If the count is equal to the number of blocks needed to completely accumulate a sub-result of matrix C, then the result is sent to the output task<ul>
<li>Takes into account the number of blocks sent from the accumulate task</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The implementation of each of these rules is presented below.</p>
<h3><a class="anchor" id="tut4-distr-rule"></a>
MatMulDistributeRule</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_rule_8hpp.html">htgs/api/IRule.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixRequestData.h&quot;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>MatMulDistributeRule : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_rule.html">htgs::IRule</a>&lt;MatrixRequestData, MatrixRequestData&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatMulDistributeRule(MatrixType type) {</div><div class="line">    this-&gt;type = type;</div><div class="line">  }</div><div class="line"></div><div class="line">  ~MatMulDistributeRule() {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4">applyRule</a>(std::shared_ptr&lt;MatrixRequestData&gt; data, <span class="keywordtype">size_t</span> pipelineId) {</div><div class="line">    <span class="keywordflow">if</span> (data-&gt;getType() == this-&gt;type) {</div><div class="line">      <a class="code" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a>(data);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::string <a class="code" href="classhtgs_1_1_i_rule.html#a148fee616c01f057ddc522f2bf6a8b20">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulDistributeRule&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  MatrixType type;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-load-rule"></a>
MatMulLoadRule</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_rule_8hpp.html">htgs/api/IRule.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockMulData.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">enum class</span> MatrixState {</div><div class="line">  NONE,</div><div class="line">  IN_FLIGHT</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>MatMulLoadRule : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_rule.html">htgs::IRule</a>&lt;MatrixBlockData&lt;Type&gt;, MatrixBlockMulData&lt;Type&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatMulLoadRule (<span class="keywordtype">size_t</span> blockWidthA, <span class="keywordtype">size_t</span> blockHeightA, <span class="keywordtype">size_t</span> blockWidthB, <span class="keywordtype">size_t</span> blockHeightB) :</div><div class="line">      blockHeightA(blockHeightA), blockWidthA(blockWidthA), blockHeightB(blockHeightB), blockWidthB(blockWidthB) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; blockWidthA; i++) {</div><div class="line">      <span class="keyword">auto</span> cState = this-&gt;allocStateContainer(blockHeightB, blockWidthA, MatrixState::NONE);</div><div class="line">      this-&gt;matrixCState.push_back(cState);</div><div class="line">    }</div><div class="line"></div><div class="line">    this-&gt;matrixAState = this-&gt;allocStateContainer(blockHeightA, blockWidthA);</div><div class="line">    this-&gt;matrixBState = this-&gt;allocStateContainer(blockHeightB, blockWidthB);</div><div class="line">  }</div><div class="line"></div><div class="line">  ~MatMulLoadRule () {</div><div class="line">    <span class="keyword">delete</span> matrixAState;</div><div class="line">    <span class="keyword">delete</span> matrixBState;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> state : this-&gt;matrixCState) {</div><div class="line">      <span class="keyword">delete</span> state;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> applyRule(std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; data, <span class="keywordtype">size_t</span> pipelineId) {</div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt; request = data-&gt;getRequest();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> rowA, rowB, colA, colB;</div><div class="line">    <span class="keywordflow">switch</span> (request-&gt;getType()) {</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixA:</div><div class="line">        rowA = request-&gt;getRow();</div><div class="line">        colA = request-&gt;getCol();</div><div class="line"></div><div class="line">        this-&gt;matrixAState-&gt;set(request-&gt;getRow(), request-&gt;getCol(), data);</div><div class="line"></div><div class="line">        rowB = colA;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (colB = 0; colB &lt; blockWidthB; colB++) {</div><div class="line">          <span class="keywordflow">if</span> (this-&gt;matrixBState-&gt;has(rowB, colB)) {</div><div class="line">            <span class="keyword">auto</span> container = matrixCState[rowB];</div><div class="line"></div><div class="line">            <span class="comment">// Check if multiplication is in flight or not</span></div><div class="line">            <span class="keywordflow">if</span> (!container-&gt;has(rowA, colB)) {</div><div class="line">              <span class="comment">// Schedule work</span></div><div class="line">              this-&gt;addResult(<span class="keyword">new</span> MatrixBlockMulData&lt;Type&gt;(data, matrixBState-&gt;get(rowB, colB), <span class="keyword">nullptr</span>));</div><div class="line">              MatrixState state = MatrixState::IN_FLIGHT;</div><div class="line">              container-&gt;set(rowA, colB, state);</div><div class="line">            }</div><div class="line">          }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixB:</div><div class="line">        rowB = request-&gt;getRow();</div><div class="line">        colB = request-&gt;getCol();</div><div class="line"></div><div class="line">        this-&gt;matrixBState-&gt;set(rowB, colB, data);</div><div class="line"></div><div class="line">        colA = rowB;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (rowA = 0; rowA &lt; blockHeightA; rowA++) {</div><div class="line">          <span class="keywordflow">if</span> (this-&gt;matrixAState-&gt;has(rowA, colA)) {</div><div class="line">            <span class="keyword">auto</span> container = matrixCState[colA];</div><div class="line"></div><div class="line">            <span class="comment">// Check if multiplication is in flight or not</span></div><div class="line">            <span class="keywordflow">if</span> (!container-&gt;has(rowA, colB)) {</div><div class="line">              <span class="comment">// Schedule work</span></div><div class="line">              this-&gt;addResult(<span class="keyword">new</span> MatrixBlockMulData&lt;Type&gt;(matrixAState-&gt;get(rowA, colA), data, <span class="keyword">nullptr</span>));</div><div class="line">              MatrixState state = MatrixState::IN_FLIGHT;</div><div class="line">              container-&gt;set(rowA, colB, state);</div><div class="line">            }</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixC:<span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixAny:<span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::string getName() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulLoadRule&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">size_t</span> blockWidthA;</div><div class="line">  <span class="keywordtype">size_t</span> blockHeightA;</div><div class="line">  <span class="keywordtype">size_t</span> blockWidthB;</div><div class="line">  <span class="keywordtype">size_t</span> blockHeightB;</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;</a>&gt;&gt; *matrixAState;</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;</a>&gt;&gt; *matrixBState;</div><div class="line">  std::vector&lt;htgs::StateContainer&lt;MatrixState&gt; *&gt; matrixCState;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-acc-rule"></a>
MatMulAccumulateRule</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_rule_8hpp.html">htgs/api/IRule.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockMulData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;MatMulOutputRule.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>MatMulAccumulateRule : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_rule.html">htgs::IRule</a>&lt;MatrixBlockData&lt;Type&gt;, MatrixBlockMulData&lt;Type&gt; &gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatMulAccumulateRule(<span class="keywordtype">size_t</span> blockWidth, <span class="keywordtype">size_t</span> blockHeight, <span class="keywordtype">size_t</span> blockWidthMatrixA) {</div><div class="line">    matrixContainer = this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#a8baa4e2f1a4126d21fe20ca378a5a72b">allocStateContainer</a>(blockHeight, blockWidth);</div><div class="line">    totalCount = blockWidth * blockHeight * blockWidthMatrixA + blockWidth * blockHeight * (blockWidthMatrixA - 1);</div><div class="line">    count = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  ~MatMulAccumulateRule() {</div><div class="line">    <span class="keyword">delete</span> matrixContainer;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classhtgs_1_1_i_rule.html#acf7da2e1b9b25fce31a4dedb34d0df94">canTerminateRule</a>(<span class="keywordtype">size_t</span> pipelineId)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> count == totalCount;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4">applyRule</a>(std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;&gt; data, <span class="keywordtype">size_t</span> pipelineId)<span class="keyword"> override </span>{</div><div class="line">    <span class="keyword">auto</span> request = data-&gt;getRequest();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> row = request-&gt;getRow();</div><div class="line">    <span class="keywordtype">size_t</span> col = request-&gt;getCol();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (matrixContainer-&gt;has(row, col)) {</div><div class="line">      <span class="keyword">auto</span> blkData = matrixContainer-&gt;get(row, col);</div><div class="line">      matrixContainer-&gt;remove(row, col);</div><div class="line">      this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a>(<span class="keyword">new</span> MatrixBlockMulData&lt;Type&gt;(blkData, data, <span class="keyword">nullptr</span>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      matrixContainer-&gt;set(row, col, data);</div><div class="line">    }</div><div class="line">    count++;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::string <a class="code" href="classhtgs_1_1_i_rule.html#a148fee616c01f057ddc522f2bf6a8b20">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulAccumulateRule&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;std::shared_ptr&lt;MatrixBlockData&lt;Type&gt;</a>&gt;&gt; *matrixContainer;</div><div class="line">  <span class="keywordtype">size_t</span> count;</div><div class="line">  <span class="keywordtype">size_t</span> totalCount;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-output-rule"></a>
MatMulOutputRule</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_rule_8hpp.html">htgs/api/IRule.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MatMulOutputRule : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_rule.html">htgs::IRule</a>&lt;MatrixBlockData&lt;double *&gt;, MatrixBlockData&lt;double *&gt; &gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatMulOutputRule(<span class="keywordtype">size_t</span> blockWidth, <span class="keywordtype">size_t</span> blockHeight, <span class="keywordtype">size_t</span> blockWidthMatrixA) {</div><div class="line">    matrixCountContainer = this-&gt;allocStateContainer&lt;size_t&gt;(blockHeight, blockWidth, 0);</div><div class="line">    numBlocks = 2 * blockWidthMatrixA - 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  ~MatMulOutputRule() {</div><div class="line">    <span class="keyword">delete</span> matrixCountContainer;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4">applyRule</a>(std::shared_ptr&lt;MatrixBlockData&lt;double *&gt;&gt; data, <span class="keywordtype">size_t</span> pipelineId)<span class="keyword"> override </span>{</div><div class="line">    <span class="keyword">auto</span> request = data-&gt;getRequest();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> row = request-&gt;getRow();</div><div class="line">    <span class="keywordtype">size_t</span> col = request-&gt;getCol();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> count = matrixCountContainer-&gt;get(row, col);</div><div class="line">    count++;</div><div class="line">    matrixCountContainer-&gt;set(row, col, count);</div><div class="line">    <span class="keywordflow">if</span> (count == numBlocks) {</div><div class="line">      <a class="code" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a>(data);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::string <a class="code" href="classhtgs_1_1_i_rule.html#a148fee616c01f057ddc522f2bf6a8b20">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulOutputRule&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;size_t&gt;</a> *matrixCountContainer;</div><div class="line">  <span class="keywordtype">size_t</span> numBlocks;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut4-bookkeeper-notes"></a>
Notes</h3>
<ul>
<li>Implementation of a <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> can be reused for multiple edges<ul>
<li>A separate instance per edge with a parameter to modify the functionality</li>
<li>The MatMulDistributeRule demonstrates this capability</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a> can be used to hold onto data objects as well as state enums or any other object<ul>
<li>The MatMulLoadRule uses it to hold onto state for both matrices A and B<ul>
<li>Matrix C is represented by a <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a> holding the enum class MatrixState to determine if computation has been initiated</li>
</ul>
</li>
</ul>
</li>
<li>If there is a cycle in a graph, then the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> is an excellent candidate for determining when to terminate the cycle<ul>
<li>MatMulAccumulateRule uses the <a class="el" href="classhtgs_1_1_i_rule.html#acf7da2e1b9b25fce31a4dedb34d0df94" title="Virtual function to determine if a rule is ready to be terminated. ">htgs::IRule::canTerminateRule</a> to indicate when to terminate the cycle</li>
<li>Moving the terminate condition into a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> can produce race conditions and may require synchronization when updating the state</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="tut4-create-and-execute-taskgraph"></a>
Creating and Executing the htgs::TaskGraphConf</h2>
<p>As shown in Tutorial1, we use the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> to build and connect all our components that can then be executed using threads.</p>
<p>Belows is the source code implementation for setup, construction of the task TaskGraph, executing the TaskGraph, and processing the output of the TaskGraph.</p>
<p>We also include functions for computing the algorithm without HTGS and validating the results.</p>
<p>To reduce code size, we have created a <a href="https://github.com/usnistgov/HTGS-Tutorials/blob/master/tutorial-utils/matrix-library/args/MatMulArgs.cpp">MatMulArgs</a> class to handle parsing command-line arguments.</p>
<p>The input matrices are initialized prior to execution, and the result matrix is assumed to have been initialized with zeros.</p>
<p>The traversal behavior is controlled within the main function when producing data for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>. In this example, we use an inner-product traversal, as shown above. This ensures that the accumulate task will begin processing as quickly as possible. The thread configuration is split between the matrix multiplication task and the accumulate task. In our testing, specifying N threads for the matrix multiplication task and N/2 threads for the accumulate task yields the best utilization. This parameters can be easily tweaked below.</p>
<h3><a class="anchor" id="tut4-main-function"></a>
Main function (Matrix Multiplication)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_conf_8hpp.html">htgs/api/TaskGraphConf.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_runtime_8hpp.html">htgs/api/TaskGraphRuntime.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;../tutorial-utils/SimpleClock.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../tutorial-utils/util-matrix.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../tutorial-utils/matrix-library/operations/matmul.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../tutorial-utils/matrix-library/args/MatMulArgs.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../tutorial-utils/matrix-library/tasks/LoadMatrixTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/MatMulBlkTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/MatMulAccumTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/MatMulOutputTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rules/MatMulDistributeRule.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rules/MatMulLoadRule.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rules/MatMulAccumulateRule.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> validateResults(<span class="keywordtype">double</span> *matrixC, <span class="keywordtype">double</span> *matrixC_HTGS, <span class="keywordtype">size_t</span> fullMatrixAHeight, <span class="keywordtype">size_t</span> fullMatrixBWidth) {</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!validateMatMulResults(20, matrixC, matrixC_HTGS, fullMatrixAHeight*fullMatrixBWidth))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> computeSequentialMatMul(<span class="keywordtype">double</span> *matrixA, <span class="keywordtype">double</span> *matrixB, <span class="keywordtype">double</span> *matrixC,</div><div class="line">                             <span class="keywordtype">size_t</span> fullMatrixAHeight, <span class="keywordtype">size_t</span> fullMatrixAWidth, <span class="keywordtype">size_t</span> fullMatrixBWidth) {</div><div class="line"></div><div class="line">  computeMatMul(fullMatrixAHeight, fullMatrixBWidth, fullMatrixAWidth, 1.0, matrixA, fullMatrixAWidth, matrixB,</div><div class="line">                fullMatrixBWidth, 0.0, matrixC, fullMatrixBWidth, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line">  MatMulArgs matMulArgs;</div><div class="line">  matMulArgs.processArgs(argc, argv);</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> matrixAHeight = matMulArgs.getMatrixAHeight();</div><div class="line">  <span class="keywordtype">size_t</span> matrixBWidth = matMulArgs.getMatrixBWidth();</div><div class="line">  <span class="keywordtype">size_t</span> sharedDim = matMulArgs.getSharedDim();</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> blockSize = matMulArgs.getBlockSize();</div><div class="line">  <span class="keywordtype">size_t</span> numReadThreads = matMulArgs.getNumReadThreads();</div><div class="line">  <span class="keywordtype">size_t</span> numProdThreads = matMulArgs.getNumMatMulThreads();</div><div class="line">  <span class="keywordtype">size_t</span> numAccumThreads = (size_t) ceil((<span class="keywordtype">double</span>)numProdThreads / 2.0);</div><div class="line">  std::string directory = matMulArgs.getDirectory();</div><div class="line">  std::string outputDirectory = matMulArgs.getOutputDir();</div><div class="line">  <span class="keywordtype">bool</span> runSequential = matMulArgs.isRunSequential();</div><div class="line">  <span class="keywordtype">bool</span> validate = matMulArgs.isValidateResults();</div><div class="line"></div><div class="line">  std::string runtimeFileStr(<span class="stringliteral">&quot;runtimes&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> numRetry = 1;</div><div class="line"></div><div class="line">  std::ofstream runtimeFile(runtimeFileStr, std::ios::app);</div><div class="line">  <span class="keywordtype">double</span> *matrixA = <span class="keyword">new</span> <span class="keywordtype">double</span>[matrixAHeight * sharedDim];</div><div class="line">  <span class="keywordtype">double</span> *matrixB = <span class="keyword">new</span> <span class="keywordtype">double</span>[matrixBWidth * sharedDim];</div><div class="line">  <span class="keywordtype">double</span> *matrixC = <span class="keyword">new</span> <span class="keywordtype">double</span>[matrixAHeight * matrixBWidth];</div><div class="line"></div><div class="line">  initMatrix(matrixA, sharedDim, matrixAHeight, <span class="keyword">false</span>);</div><div class="line">  initMatrix(matrixB, matrixBWidth, sharedDim, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> numTry = 0; numTry &lt; numRetry; numTry++) {</div><div class="line">    SimpleClock clk;</div><div class="line">    SimpleClock endToEnd;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (runSequential) {</div><div class="line">      endToEnd.start();</div><div class="line">      initMatMul(numProdThreads);</div><div class="line"></div><div class="line">      clk.start();</div><div class="line">      computeSequentialMatMul(matrixA, matrixB, matrixC, matrixAHeight, sharedDim, matrixBWidth);</div><div class="line">      clk.stopAndIncrement();</div><div class="line">      endToEnd.stopAndIncrement();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      endToEnd.start();</div><div class="line">      initMatMul(1);</div><div class="line"></div><div class="line">      LoadMatrixTask *readAMatTask =</div><div class="line">          <span class="keyword">new</span> LoadMatrixTask(matrixA,</div><div class="line">                             numReadThreads,</div><div class="line">                             MatrixType::MatrixA,</div><div class="line">                             blockSize,</div><div class="line">                             sharedDim,</div><div class="line">                             matrixAHeight,</div><div class="line">                             <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      LoadMatrixTask *readBMatTask =</div><div class="line">          <span class="keyword">new</span> LoadMatrixTask(matrixB,</div><div class="line">                             numReadThreads,</div><div class="line">                             MatrixType::MatrixB,</div><div class="line">                             blockSize,</div><div class="line">                             matrixBWidth,</div><div class="line">                             sharedDim,</div><div class="line">                             <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      MatMulBlkTask *mmulTask = <span class="keyword">new</span> MatMulBlkTask(numProdThreads, <span class="keyword">false</span>);</div><div class="line">      MatMulAccumTask *accumTask = <span class="keyword">new</span> MatMulAccumTask(numAccumThreads, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      MatMulOutputTask *outputTask = <span class="keyword">new</span> MatMulOutputTask(matrixC, matrixBWidth, blockSize, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      <span class="keywordtype">size_t</span> blkHeightMatB = readBMatTask-&gt;getNumBlocksRows();</div><div class="line">      <span class="keywordtype">size_t</span> blkWidthMatB = readBMatTask-&gt;getNumBlocksCols();</div><div class="line"></div><div class="line">      <span class="keywordtype">size_t</span> blkHeightMatA = readAMatTask-&gt;getNumBlocksRows();</div><div class="line">      <span class="keywordtype">size_t</span> blkWidthMatA = readAMatTask-&gt;getNumBlocksCols();</div><div class="line"></div><div class="line">      MatMulDistributeRule *distributeRuleMatA = <span class="keyword">new</span> MatMulDistributeRule(MatrixType::MatrixA);</div><div class="line">      MatMulDistributeRule *distributeRuleMatB = <span class="keyword">new</span> MatMulDistributeRule(MatrixType::MatrixB);</div><div class="line"></div><div class="line">      MatMulLoadRule&lt;double *&gt; *loadRule = <span class="keyword">new</span> MatMulLoadRule&lt;double *&gt;(blkWidthMatA, blkHeightMatA, blkWidthMatB, blkHeightMatB);</div><div class="line">      MatMulAccumulateRule&lt;double *&gt; *accumulateRule = <span class="keyword">new</span> MatMulAccumulateRule&lt;double *&gt;(blkWidthMatB, blkHeightMatA, blkWidthMatA);</div><div class="line"></div><div class="line">      MatMulOutputRule *outputRule = <span class="keyword">new</span> MatMulOutputRule(blkWidthMatB, blkHeightMatA, blkWidthMatA);</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> distributeBk = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixRequestData&gt;</a>();</div><div class="line">      <span class="keyword">auto</span> matMulBk = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&lt;double *&gt;</a>&gt;();</div><div class="line">      <span class="keyword">auto</span> matAccumBk = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&lt;double *&gt;</a>&gt;();</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixRequestData, MatrixRequestData&gt;</a>();</div><div class="line"></div><div class="line">      taskGraph-&gt;setGraphConsumerTask(distributeBk);</div><div class="line">      taskGraph-&gt;addRuleEdge(distributeBk, distributeRuleMatA, readAMatTask);</div><div class="line">      taskGraph-&gt;addRuleEdge(distributeBk, distributeRuleMatB, readBMatTask);</div><div class="line"></div><div class="line">      taskGraph-&gt;addEdge(readAMatTask, matMulBk);</div><div class="line">      taskGraph-&gt;addEdge(readBMatTask, matMulBk);</div><div class="line"></div><div class="line">      taskGraph-&gt;addRuleEdge(matMulBk, loadRule, mmulTask);</div><div class="line"></div><div class="line">      taskGraph-&gt;addEdge(mmulTask, matAccumBk);</div><div class="line">      taskGraph-&gt;addRuleEdge(matAccumBk, accumulateRule, accumTask);</div><div class="line">      taskGraph-&gt;addEdge(accumTask, matAccumBk);</div><div class="line"></div><div class="line">      taskGraph-&gt;addRuleEdge(matAccumBk, outputRule, outputTask);</div><div class="line">      taskGraph-&gt;addGraphProducerTask(outputTask);</div><div class="line"></div><div class="line">      <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a> *runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a>(taskGraph);</div><div class="line"></div><div class="line">      clk.start();</div><div class="line"></div><div class="line">      runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9">executeRuntime</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; blkHeightMatA; row++) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; blkWidthMatA; col++) {</div><div class="line"></div><div class="line">          MatrixRequestData *matA = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixA);</div><div class="line">          taskGraph-&gt;produceData(matA);</div><div class="line"></div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; blkWidthMatB; col++) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; blkHeightMatB; row++) {</div><div class="line">          MatrixRequestData *matB = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixB);</div><div class="line">          taskGraph-&gt;produceData(matB);</div><div class="line"></div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">      taskGraph-&gt;finishedProducingData();</div><div class="line"></div><div class="line">      <span class="keywordflow">while</span> (!taskGraph-&gt;isOutputTerminated()) {</div><div class="line">        <span class="keyword">auto</span> data = taskGraph-&gt;consumeData();</div><div class="line">        <span class="keywordflow">if</span> (data != <span class="keyword">nullptr</span>) {</div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">      runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a8f2eaf040695178b6f61db7b0ee16c89">waitForRuntime</a>();</div><div class="line">      clk.stopAndIncrement();</div><div class="line"></div><div class="line">      <span class="keyword">delete</span> runtime;</div><div class="line">      endToEnd.stopAndIncrement();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (validate) {</div><div class="line">      <span class="keywordtype">double</span> *matrixCTest = <span class="keyword">new</span> <span class="keywordtype">double</span>[matrixAHeight * matrixBWidth];</div><div class="line">      computeSequentialMatMul(matrixA, matrixB, matrixCTest, matrixAHeight, sharedDim, matrixBWidth);</div><div class="line"></div><div class="line">      <span class="keywordtype">int</span> res = validateResults(matrixC, matrixCTest, matrixAHeight, matrixBWidth);</div><div class="line">      <span class="keywordflow">if</span> (res != 0) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error validating test failed!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Test PASSED&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; (runSequential ? <span class="stringliteral">&quot;sequential&quot;</span> : <span class="stringliteral">&quot;htgs&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; numProdThreads</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, accum-threads: &quot;</span> &lt;&lt; numAccumThreads &lt;&lt; <span class="stringliteral">&quot;, width-b: &quot;</span> &lt;&lt; matrixBWidth &lt;&lt; <span class="stringliteral">&quot;, height-a: &quot;</span> &lt;&lt; matrixAHeight</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, shared-dim: &quot;</span> &lt;&lt; sharedDim</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, blockSize: &quot;</span> &lt;&lt; (runSequential ? 0 : blockSize) </div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, time:&quot;</span> &lt;&lt; clk.getAverageTime(TimeVal::MILLI)</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, end-to-end:&quot;</span> &lt;&lt; endToEnd.getAverageTime(TimeVal::MILLI)</div><div class="line"></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    runtimeFile &lt;&lt; (runSequential ? <span class="stringliteral">&quot;sequential&quot;</span> : <span class="stringliteral">&quot;htgs&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; numProdThreads</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; numAccumThreads &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div><div class="line">                &lt;&lt; matrixBWidth &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; matrixAHeight</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; sharedDim &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; blockSize &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; clk.getAverageTime(TimeVal::MILLI)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; endToEnd.getAverageTime(TimeVal::MILLI)</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">delete</span>[] matrixA;</div><div class="line">  <span class="keyword">delete</span>[] matrixB;</div><div class="line">  <span class="keyword">delete</span>[] matrixC;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Sample executions: </p><div class="fragment"><div class="line">./tutorial3 --block-size 128 --validate-results</div><div class="line">Test PASSED</div><div class="line">htgs, 20, accum-threads: 10, width-b: 1024, height-a: 1024, shared-dim: 1024, blockSize: 128, time:237.595, end-to-end:237.939</div><div class="line"></div><div class="line">./tutorial3 --block-size 128 --run-sequential --validate-results</div><div class="line">Test PASSED</div><div class="line">sequential, 20, accum-threads: 5, width-b: 1024, height-a: 1024, shared-dim: 1024, blockSize: 0, time:2404.68, end-to-end:2404.68</div><div class="line"></div><div class="line">./tutorial3 --block-size 128 --validate-results --width-b 2048 --height-a 2048 --shared-dim 2048 --num-workers 20</div><div class="line">Test PASSED</div><div class="line">htgs, 20, accum-threads: 10, width-b: 2048, height-a: 2048, shared-dim: 2048, blockSize: 128, time:1173.33, end-to-end:1173.76</div><div class="line"></div><div class="line">./tutorial3 --block-size 128 --run-sequential --validate-results --width-b 2048 --height-a 2048 --shared-dim 2048</div><div class="line">Test PASSED</div><div class="line">sequential, 20, accum-threads: 5, width-b: 2048, height-a: 2048, shared-dim: 2048, blockSize: 0, time:61167.1, end-to-end:61167.1</div></div><!-- fragment --><h3><a class="anchor" id="tut4-taskgraph-notes"></a>
Notes</h3>
<ul>
<li>Choosing a good traversal can impact utilization of tasks<ul>
<li>Initiating the accumulate task as quickly as possible using an inner-product</li>
</ul>
</li>
<li>Sample executions demonstrate performance between single-threaded version and multi-threaded with HTGS<ul>
<li>In small experiment (1024x1024 above) results in 10x speedup compared to sequential</li>
<li>Slightly larger experiment (2048x2048) results in 52x speedup compared to sequential<ul>
<li>HTGS specifies 20 threads for matrix multiplication and 10 threads for accumulate</li>
<li>Sequential version uses 1 thread</li>
<li>System specs: 2x-Xeon E5-2650 v3 @ 2.30GHz (20 physical cores, 40 logical)</li>
<li>Using smaller block size improves locality and cache coherency</li>
</ul>
</li>
<li>Picking the right block size impacts utilization in HTGS (can be architecture-dependent)<ul>
<li>Can be used to improve cache usage</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="tut4-summary"></a>
Summary </h1>
<p>In this tutorial, we looked at implementing the matrix multiplication algorithm. This algorithm posed some three interesting challenges:</p><ol type="1">
<li>Representing a complex dependency</li>
<li>Ways to improve parallelism<ul>
<li>At the cost of using more memory</li>
</ul>
</li>
<li>How to represent a cycle and terminate it within the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
</ol>
<p>The most significant aspect of implementing matrix multiplication and any other algorithim with HTGS is understanding how to represent data and, as a result, how that representation impacts the use of data. From this data representation, decisions are made to improve parallelism, locality, and overall utilization of architectures.</p>
<p>Once a basic representation of the algorithm can be developed in HTGS, then that algorithm can be analyzed at a higher level of abstraction. This is achieved through the explicit representation of the graph within HTGS and its ability to write that representation to file. Using profiling tools, this representation can provide visual feedback as to how the algorithm is performing, which can be used to pinpoint bottlenecks. In <a class="el" href="tutorial3b.html">part b of this tutorial</a> we will look deeper into some of the tools available and identify the bottlenecks associated with this implementation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
