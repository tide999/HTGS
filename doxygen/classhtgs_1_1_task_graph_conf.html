<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: htgs::TaskGraphConf&lt; T, U &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhtgs_1_1_task_graph_conf.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhtgs_1_1_task_graph_conf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">htgs::TaskGraphConf&lt; T, U &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages a group of connected ITasks and their connections.  
 <a href="classhtgs_1_1_task_graph_conf.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_task_graph_conf_8hpp_source.html">htgs/api/TaskGraphConf.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for htgs::TaskGraphConf&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_task_graph_conf__inherit__graph.png" border="0" usemap="#htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_inherit__map" id="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_inherit__map">
<area shape="rect" id="node2" href="classhtgs_1_1_any_task_graph_conf.html" title="Implements the base class for the TaskGraphConf class, removing the template arguments and providing ..." alt="" coords="23,5,209,449"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for htgs::TaskGraphConf&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_task_graph_conf__coll__graph.png" border="0" usemap="#htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_coll__map" id="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_coll__map">
<area shape="rect" id="node2" href="classhtgs_1_1_any_task_graph_conf.html" title="Implements the base class for the TaskGraphConf class, removing the template arguments and providing ..." alt="" coords="209,1011,394,1367"/>
<area shape="rect" id="node3" title="STL class. " alt="" coords="243,764,365,841"/>
<area shape="rect" id="node6" title="STL class. " alt="" coords="389,757,555,849"/>
<area shape="rect" id="node8" href="classhtgs_1_1_any_task_manager.html" title="The parent class for a Task that removes the template arguments. " alt="" coords="9,287,167,657"/>
<area shape="rect" id="node9" title="STL class. " alt="" coords="107,147,187,224"/>
<area shape="rect" id="node10" title="STL class. " alt="" coords="83,5,210,97"/>
<area shape="rect" id="node12" href="classhtgs_1_1_graph_edge.html" title="{htgs::GraphEdge\&lt; U \&gt;\n|&#45; graphConnector\l|+ GraphEdge()\l+ ~GraphEdge()\l+ getGraphConnector()\l+ setConnector()\l+ copy()\l+ updateEdge()\l+ getTaskManager()\l}" alt="" coords="588,720,743,885"/>
<area shape="rect" id="node13" href="classhtgs_1_1_edge_descriptor.html" title="The edge descriptor is an interface used to describe how an edge is applied and copied to a task grap..." alt="" coords="670,419,815,525"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5be2d8e8919ab1e7b23da33cb74c8ad5"><td class="memItemLeft" align="right" valign="top"><a id="a5be2d8e8919ab1e7b23da33cb74c8ad5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a5be2d8e8919ab1e7b23da33cb74c8ad5">TaskGraphConf</a> ()</td></tr>
<tr class="memdesc:a5be2d8e8919ab1e7b23da33cb74c8ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a TaskGraph. <br /></td></tr>
<tr class="separator:a5be2d8e8919ab1e7b23da33cb74c8ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce9d842849be607b3ef2626eedff2f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#adce9d842849be607b3ef2626eedff2f9">TaskGraphConf</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>, std::string baseAddress)</td></tr>
<tr class="memdesc:adce9d842849be607b3ef2626eedff2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a TaskGraph.  <a href="#adce9d842849be607b3ef2626eedff2f9">More...</a><br /></td></tr>
<tr class="separator:adce9d842849be607b3ef2626eedff2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f679f264c726a61ea7ae50f02914a"><td class="memItemLeft" align="right" valign="top"><a id="a323f679f264c726a61ea7ae50f02914a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a323f679f264c726a61ea7ae50f02914a">~TaskGraphConf</a> () override</td></tr>
<tr class="memdesc:a323f679f264c726a61ea7ae50f02914a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, handles releasing all <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> memory that is managed by the TaskGraph. <br /></td></tr>
<tr class="separator:a323f679f264c726a61ea7ae50f02914a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6885d5ddfcee1dadee68e5b9a586a0f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html">AnyTaskGraphConf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a6885d5ddfcee1dadee68e5b9a586a0f1">copy</a> () override</td></tr>
<tr class="memdesc:a6885d5ddfcee1dadee68e5b9a586a0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an exact copy of this task graph.  <a href="#a6885d5ddfcee1dadee68e5b9a586a0f1">More...</a><br /></td></tr>
<tr class="separator:a6885d5ddfcee1dadee68e5b9a586a0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163409dd38587f67b49502835ca107fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a163409dd38587f67b49502835ca107fe">copy</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>)</td></tr>
<tr class="memdesc:a163409dd38587f67b49502835ca107fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines.  <a href="#a163409dd38587f67b49502835ca107fe">More...</a><br /></td></tr>
<tr class="separator:a163409dd38587f67b49502835ca107fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538400eab48faf2e6ca2f12eee77f86c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a538400eab48faf2e6ca2f12eee77f86c">copy</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html#a9c072839d748de933ae96371313dd52d">input</a>, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html#a93f6a48dc9c378889e2b48ca70e27776">output</a>, std::string baseAddress)</td></tr>
<tr class="memdesc:a538400eab48faf2e6ca2f12eee77f86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines, and updates the input and output connectors for the graph copy.  <a href="#a538400eab48faf2e6ca2f12eee77f86c">More...</a><br /></td></tr>
<tr class="separator:a538400eab48faf2e6ca2f12eee77f86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf80f060f13a40b41579a8678acad01"><td class="memTemplParams" colspan="2">template&lt;class V , class W , class X &gt; </td></tr>
<tr class="memitem:aeaf80f060f13a40b41579a8678acad01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01">addEdge</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; V, W &gt; *producer, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="memdesc:aeaf80f060f13a40b41579a8678acad01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph, where one task produces data for a consumer task.  <a href="#aeaf80f060f13a40b41579a8678acad01">More...</a><br /></td></tr>
<tr class="separator:aeaf80f060f13a40b41579a8678acad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfc932815a7b264da00c35d274f5274"><td class="memTemplParams" colspan="2">template&lt;class V , class IRuleType , class W , class X &gt; </td></tr>
<tr class="memitem:aedfc932815a7b264da00c35d274f5274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274">addRuleEdge</a> (<a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *bookkeeper, std::shared_ptr&lt; IRuleType &gt; rule, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="memdesc:aedfc932815a7b264da00c35d274f5274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rule edge that is managed by a bookkeeper.  <a href="#aedfc932815a7b264da00c35d274f5274">More...</a><br /></td></tr>
<tr class="separator:aedfc932815a7b264da00c35d274f5274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="memTemplParams" colspan="2">template&lt;class V , class W , class X &gt; </td></tr>
<tr class="memitem:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#ac3d41cc1d73dfda04f8f9ab48a525980">addRuleEdge</a> (<a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *bookkeeper, <a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; *iRule, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="memdesc:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rule edge that is managed by a bookkeeper.  <a href="#ac3d41cc1d73dfda04f8f9ab48a525980">More...</a><br /></td></tr>
<tr class="separator:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dbeb77366351e99aabf1e34149855a"><td class="memTemplParams" colspan="2">template&lt;class V , class IMemoryAllocatorType &gt; </td></tr>
<tr class="memitem:a48dbeb77366351e99aabf1e34149855a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a48dbeb77366351e99aabf1e34149855a">addCudaMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type, int *gpuIds)</td></tr>
<tr class="memdesc:a48dbeb77366351e99aabf1e34149855a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a48dbeb77366351e99aabf1e34149855a">More...</a><br /></td></tr>
<tr class="separator:a48dbeb77366351e99aabf1e34149855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854ec9f27f6c9c423b1090aa9910fbff"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a854ec9f27f6c9c423b1090aa9910fbff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a854ec9f27f6c9c423b1090aa9910fbff">addCudaMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type, int *gpuIds)</td></tr>
<tr class="memdesc:a854ec9f27f6c9c423b1090aa9910fbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a854ec9f27f6c9c423b1090aa9910fbff">More...</a><br /></td></tr>
<tr class="separator:a854ec9f27f6c9c423b1090aa9910fbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5669ca25671b3761fafc359813b802"><td class="memTemplParams" colspan="2"><a id="abb5669ca25671b3761fafc359813b802"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:abb5669ca25671b3761fafc359813b802"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addRuleEdgeAsGraphProducer</b> (<a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *bookkeeper, <a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, U &gt; *iRule)</td></tr>
<tr class="separator:abb5669ca25671b3761fafc359813b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a3e01d687d11fcd4a7c9bd90f8f65a7f3">addCustomMemoryManagerEdge</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_memory_manager.html">MemoryManager</a>&lt; V &gt; *memoryManager)</td></tr>
<tr class="memdesc:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a3e01d687d11fcd4a7c9bd90f8f65a7f3">More...</a><br /></td></tr>
<tr class="separator:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88adcd11f63ba49703f82f1210d0f0eb"><td class="memTemplParams" colspan="2">template&lt;class V , class IMemoryAllocatorType &gt; </td></tr>
<tr class="memitem:a88adcd11f63ba49703f82f1210d0f0eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb">addMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type)</td></tr>
<tr class="memdesc:a88adcd11f63ba49703f82f1210d0f0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a88adcd11f63ba49703f82f1210d0f0eb">More...</a><br /></td></tr>
<tr class="separator:a88adcd11f63ba49703f82f1210d0f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442420d2c9c115ca9f9c644f7e5c985f"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a442420d2c9c115ca9f9c644f7e5c985f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a442420d2c9c115ca9f9c644f7e5c985f">addMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type)</td></tr>
<tr class="memdesc:a442420d2c9c115ca9f9c644f7e5c985f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a442420d2c9c115ca9f9c644f7e5c985f">More...</a><br /></td></tr>
<tr class="separator:a442420d2c9c115ca9f9c644f7e5c985f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefecdde12a738f08e41f410015afb6e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#abefecdde12a738f08e41f410015afb6e">getInputConnector</a> () override</td></tr>
<tr class="memdesc:abefecdde12a738f08e41f410015afb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that gets the task manager that is consuming data from the graph's input.  <a href="#abefecdde12a738f08e41f410015afb6e">More...</a><br /></td></tr>
<tr class="separator:abefecdde12a738f08e41f410015afb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a06907ead06a968ab1530922a0ea2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a2d3a06907ead06a968ab1530922a0ea2">getOutputConnector</a> () override</td></tr>
<tr class="memdesc:a2d3a06907ead06a968ab1530922a0ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that gets the connector used for graph output.  <a href="#a2d3a06907ead06a968ab1530922a0ea2">More...</a><br /></td></tr>
<tr class="separator:a2d3a06907ead06a968ab1530922a0ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea9cf75785a9ab08bd5333062714e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#adea9cf75785a9ab08bd5333062714e45">updateTaskManagersAddressingAndPipelines</a> ()</td></tr>
<tr class="memdesc:adea9cf75785a9ab08bd5333062714e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the task managers addresses, pipelineIds and the number of pipelines for all tasks in the TaskGraph.  <a href="#adea9cf75785a9ab08bd5333062714e45">More...</a><br /></td></tr>
<tr class="separator:adea9cf75785a9ab08bd5333062714e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9a2ea9704c804e089c1794e1e8e664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a5d9a2ea9704c804e089c1794e1e8e664">incrementGraphProducer</a> ()</td></tr>
<tr class="memdesc:a5d9a2ea9704c804e089c1794e1e8e664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input connector for the task graph.  <a href="#a5d9a2ea9704c804e089c1794e1e8e664">More...</a><br /></td></tr>
<tr class="separator:a5d9a2ea9704c804e089c1794e1e8e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1e54bfce0472b38d422f973d3ba68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d">finishedProducingData</a> ()</td></tr>
<tr class="memdesc:a2c1e54bfce0472b38d422f973d3ba68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the input connector and wakes up any consumer of the graph's input if the input connector is finished producing data.  <a href="#a2c1e54bfce0472b38d422f973d3ba68d">More...</a><br /></td></tr>
<tr class="separator:a2c1e54bfce0472b38d422f973d3ba68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23520b3b3054e16c59784b0d3a289811"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:a23520b3b3054e16c59784b0d3a289811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811">setGraphConsumerTask</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, W &gt; *task)</td></tr>
<tr class="memdesc:a23520b3b3054e16c59784b0d3a289811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the task that is consuming data from the input of the graph.  <a href="#a23520b3b3054e16c59784b0d3a289811">More...</a><br /></td></tr>
<tr class="separator:a23520b3b3054e16c59784b0d3a289811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0857e5a678b01922a513cd2327114864"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:a0857e5a678b01922a513cd2327114864"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a0857e5a678b01922a513cd2327114864">addGraphProducerTask</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, U &gt; *task)</td></tr>
<tr class="memdesc:a0857e5a678b01922a513cd2327114864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the task that is producing data for the output of the graph.  <a href="#a0857e5a678b01922a513cd2327114864">More...</a><br /></td></tr>
<tr class="separator:a0857e5a678b01922a513cd2327114864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834c5f5f07d3cceac5d7f6f9e128e7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef">produceData</a> (T *data)</td></tr>
<tr class="memdesc:a834c5f5f07d3cceac5d7f6f9e128e7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces data for the input of the TaskGraph.  <a href="#a834c5f5f07d3cceac5d7f6f9e128e7ef">More...</a><br /></td></tr>
<tr class="separator:a834c5f5f07d3cceac5d7f6f9e128e7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614839d80ed96f8938d38606e895225a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a614839d80ed96f8938d38606e895225a">produceData</a> (std::shared_ptr&lt; T &gt; data)</td></tr>
<tr class="memdesc:a614839d80ed96f8938d38606e895225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces data for the input of the TaskGraph.  <a href="#a614839d80ed96f8938d38606e895225a">More...</a><br /></td></tr>
<tr class="separator:a614839d80ed96f8938d38606e895225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054eb3b880cd8935d9bfad3a42e1c274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a054eb3b880cd8935d9bfad3a42e1c274">produceData</a> (std::list&lt; std::shared_ptr&lt; T &gt;&gt; *dataList)</td></tr>
<tr class="memdesc:a054eb3b880cd8935d9bfad3a42e1c274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of data into the TaskGraph Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph.  <a href="#a054eb3b880cd8935d9bfad3a42e1c274">More...</a><br /></td></tr>
<tr class="separator:a054eb3b880cd8935d9bfad3a42e1c274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fa554c295c9ff11fde6b3473d53676"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676">consumeData</a> ()</td></tr>
<tr class="memdesc:ab8fa554c295c9ff11fde6b3473d53676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes data from the output of a TaskGraph.  <a href="#ab8fa554c295c9ff11fde6b3473d53676">More...</a><br /></td></tr>
<tr class="separator:ab8fa554c295c9ff11fde6b3473d53676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec690fd65d8cc54c0631f1a813bb07c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a4ec690fd65d8cc54c0631f1a813bb07c">pollData</a> (size_t microTimeout)</td></tr>
<tr class="memdesc:a4ec690fd65d8cc54c0631f1a813bb07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls for data from the output of the TaskGraph.  <a href="#a4ec690fd65d8cc54c0631f1a813bb07c">More...</a><br /></td></tr>
<tr class="separator:a4ec690fd65d8cc54c0631f1a813bb07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbd07f1ea2ee2afb70665f5873407ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea">isOutputTerminated</a> ()</td></tr>
<tr class="memdesc:acdbd07f1ea2ee2afb70665f5873407ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the output of the TaskGraph has finished producing data.  <a href="#acdbd07f1ea2ee2afb70665f5873407ea">More...</a><br /></td></tr>
<tr class="separator:acdbd07f1ea2ee2afb70665f5873407ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c770403588c32b77f7ffbfdb0474df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c770403588c32b77f7ffbfdb0474df0">setOutputConnector</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; connector)</td></tr>
<tr class="memdesc:a2c770403588c32b77f7ffbfdb0474df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output connector for the task graph configuration.  <a href="#a2c770403588c32b77f7ffbfdb0474df0">More...</a><br /></td></tr>
<tr class="separator:a2c770403588c32b77f7ffbfdb0474df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc328ee2d85ab7841d3d608f2379b313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#abc328ee2d85ab7841d3d608f2379b313">setInputConnector</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; connector)</td></tr>
<tr class="memdesc:abc328ee2d85ab7841d3d608f2379b313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input connector for the task graph configuration.  <a href="#abc328ee2d85ab7841d3d608f2379b313">More...</a><br /></td></tr>
<tr class="separator:abc328ee2d85ab7841d3d608f2379b313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ea35e80b6f26adaefed94f09598ef7"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a87ea35e80b6f26adaefed94f09598ef7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a87ea35e80b6f26adaefed94f09598ef7">releaseMemory</a> (<a class="el" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">m_data_t</a>&lt; V &gt; memory)</td></tr>
<tr class="memdesc:a87ea35e80b6f26adaefed94f09598ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory back to its memory manager.  <a href="#a87ea35e80b6f26adaefed94f09598ef7">More...</a><br /></td></tr>
<tr class="separator:a87ea35e80b6f26adaefed94f09598ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb21b53a773e25473385e0bc714a6677"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#adb21b53a773e25473385e0bc714a6677">genCustomDotForTasks</a> (<a class="el" href="classhtgs_1_1_profile_utils.html">ProfileUtils</a> *profileUtils, int colorFlag)</td></tr>
<tr class="memdesc:adb21b53a773e25473385e0bc714a6677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the custom dot profiles for all tasks in this graph.  <a href="#adb21b53a773e25473385e0bc714a6677">More...</a><br /></td></tr>
<tr class="separator:adb21b53a773e25473385e0bc714a6677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd8e80fa9e22331d702683c3ebf5fda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a5dd8e80fa9e22331d702683c3ebf5fda">genDotGraphEdgesWithoutConnectors</a> (std::map&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *, <a class="el" href="classhtgs_1_1_task_manager_profile.html">TaskManagerProfile</a> *&gt; *allTaskManagerProfiles, int flags)</td></tr>
<tr class="memdesc:a5dd8e80fa9e22331d702683c3ebf5fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the edges between tasks without connectors.  <a href="#a5dd8e80fa9e22331d702683c3ebf5fda">More...</a><br /></td></tr>
<tr class="separator:a5dd8e80fa9e22331d702683c3ebf5fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338ef9924ca044a020865e1b2359118c"><td class="memItemLeft" align="right" valign="top"><a id="a338ef9924ca044a020865e1b2359118c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a338ef9924ca044a020865e1b2359118c">genDotGraph</a> (int flags, int colorFlag, std::string graphTitle=&quot;&quot;, std::string customTitleText=&quot;&quot;) override</td></tr>
<tr class="memdesc:a338ef9924ca044a020865e1b2359118c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the dot graph as a string. <br /></td></tr>
<tr class="separator:a338ef9924ca044a020865e1b2359118c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce4d72dc9c5ad94762d75778dfc650f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a8ce4d72dc9c5ad94762d75778dfc650f">debug</a> ()</td></tr>
<tr class="memdesc:a8ce4d72dc9c5ad94762d75778dfc650f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides debug output for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a8ce4d72dc9c5ad94762d75778dfc650f">More...</a><br /></td></tr>
<tr class="separator:a8ce4d72dc9c5ad94762d75778dfc650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329871e557370e432de17e9edb3de39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_execution_pipeline.html">ExecutionPipeline</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a329871e557370e432de17e9edb3de39f">createExecutionPipeline</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>, std::string name=&quot;Execution Pipeline&quot;, bool waitForInit=true)</td></tr>
<tr class="memdesc:a329871e557370e432de17e9edb3de39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps this task graph into an execution pipeline task, which will then be used to duplicate and execute across multiple GPUs.  <a href="#a329871e557370e432de17e9edb3de39f">More...</a><br /></td></tr>
<tr class="separator:a329871e557370e432de17e9edb3de39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e5a3f38042c8f2508c83865c578426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_t_g_task.html">TGTask</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#aa9e5a3f38042c8f2508c83865c578426">createTaskGraphTask</a> (std::string name=&quot;TGTask&quot;, bool waitForInit=true)</td></tr>
<tr class="memdesc:aa9e5a3f38042c8f2508c83865c578426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps this task graph into a <a class="el" href="classhtgs_1_1_t_g_task.html" title="TGTask is the task graph task, which is used to bundle a graph as a task, which can then be connected...">TGTask</a>.  <a href="#aa9e5a3f38042c8f2508c83865c578426">More...</a><br /></td></tr>
<tr class="separator:aa9e5a3f38042c8f2508c83865c578426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69200bf7b11c5507f9067836fff21ff0"><td class="memItemLeft" align="right" valign="top"><a id="a69200bf7b11c5507f9067836fff21ff0"></a>
<a class="el" href="classhtgs_1_1_graph_edge.html">GraphEdge</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getGraphConsumerEdge</b> () const</td></tr>
<tr class="separator:a69200bf7b11c5507f9067836fff21ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47730aec5ea65bdbd2205a1d7f0f42b9"><td class="memItemLeft" align="right" valign="top"><a id="a47730aec5ea65bdbd2205a1d7f0f42b9"></a>
std::list&lt; <a class="el" href="classhtgs_1_1_graph_edge.html">GraphEdge</a>&lt; U &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getGraphProducerEdges</b> () const</td></tr>
<tr class="separator:a47730aec5ea65bdbd2205a1d7f0f42b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_any_task_graph_conf"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_any_task_graph_conf')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_any_task_graph_conf.html">htgs::AnyTaskGraphConf</a></td></tr>
<tr class="memitem:ac7404c7ca9008030ddcefad3739ee04b inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ac7404c7ca9008030ddcefad3739ee04b">AnyTaskGraphConf</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>, std::string baseAddress)</td></tr>
<tr class="memdesc:ac7404c7ca9008030ddcefad3739ee04b inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <a class="el" href="classhtgs_1_1_any_task_graph_conf.html" title="Implements the base class for the TaskGraphConf class, removing the template arguments and providing ...">AnyTaskGraphConf</a>.  <a href="classhtgs_1_1_any_task_graph_conf.html#ac7404c7ca9008030ddcefad3739ee04b">More...</a><br /></td></tr>
<tr class="separator:ac7404c7ca9008030ddcefad3739ee04b inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802614708b3061b14d45a670111a91ee inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a id="a802614708b3061b14d45a670111a91ee"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a802614708b3061b14d45a670111a91ee">~AnyTaskGraphConf</a> ()</td></tr>
<tr class="memdesc:a802614708b3061b14d45a670111a91ee inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a802614708b3061b14d45a670111a91ee inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5070d48b8ad2c2ff5117424ae719d68c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a5070d48b8ad2c2ff5117424ae719d68c">getTaskManagers</a> ()</td></tr>
<tr class="memdesc:a5070d48b8ad2c2ff5117424ae719d68c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that initiates updating the task graph communicator.  <a href="classhtgs_1_1_any_task_graph_conf.html#a5070d48b8ad2c2ff5117424ae719d68c">More...</a><br /></td></tr>
<tr class="separator:a5070d48b8ad2c2ff5117424ae719d68c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c9c79202983d836b1efa6dfef055a5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a41c9c79202983d836b1efa6dfef055a5">gatherProfilingData</a> (std::map&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *, <a class="el" href="classhtgs_1_1_task_manager_profile.html">TaskManagerProfile</a> *&gt; *taskManagerProfiles)</td></tr>
<tr class="memdesc:a41c9c79202983d836b1efa6dfef055a5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers profiling data for this task graph's task managers, which is added into the task manager profiles map.  <a href="classhtgs_1_1_any_task_graph_conf.html#a41c9c79202983d836b1efa6dfef055a5">More...</a><br /></td></tr>
<tr class="separator:a41c9c79202983d836b1efa6dfef055a5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class V , class W &gt; </td></tr>
<tr class="memitem:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ae20f6e3b02e10eb00d5bbd3510bdf9ff">getIRule</a> (<a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; *iRule)</td></tr>
<tr class="memdesc:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shared_ptr reference for a particular <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a>.  <a href="classhtgs_1_1_any_task_graph_conf.html#ae20f6e3b02e10eb00d5bbd3510bdf9ff">More...</a><br /></td></tr>
<tr class="separator:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ab580a3d1577bf931655cf71ee3e1afb7">getMemoryAllocator</a> (<a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *allocator)</td></tr>
<tr class="memdesc:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shared_ptr reference for a particular <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">IMemoryAllocator</a>.  <a href="classhtgs_1_1_any_task_graph_conf.html#ab580a3d1577bf931655cf71ee3e1afb7">More...</a><br /></td></tr>
<tr class="separator:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19d20385562125945430fff451b1347 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a id="aa19d20385562125945430fff451b1347"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aa19d20385562125945430fff451b1347">initialize</a> ()</td></tr>
<tr class="memdesc:aa19d20385562125945430fff451b1347 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the task graph just prior to spawning threads. <br /></td></tr>
<tr class="separator:aa19d20385562125945430fff451b1347 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46c478f7f1b50b4446ea78a2ded0f1c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a id="aa46c478f7f1b50b4446ea78a2ded0f1c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aa46c478f7f1b50b4446ea78a2ded0f1c">finishedSetup</a> ()</td></tr>
<tr class="memdesc:aa46c478f7f1b50b4446ea78a2ded0f1c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the task graph has finished setting up its tasks and launched all threads for the graph. <br /></td></tr>
<tr class="separator:aa46c478f7f1b50b4446ea78a2ded0f1c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db4ca040c4aa9119239e63f634e155a inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a id="a1db4ca040c4aa9119239e63f634e155a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a1db4ca040c4aa9119239e63f634e155a">shutdown</a> ()</td></tr>
<tr class="memdesc:a1db4ca040c4aa9119239e63f634e155a inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all the threads in this graph have finished executing. <br /></td></tr>
<tr class="separator:a1db4ca040c4aa9119239e63f634e155a inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb739efc1bbdab2da5881e70625ad97 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a5bb739efc1bbdab2da5881e70625ad97">waitForInitialization</a> ()</td></tr>
<tr class="memdesc:a5bb739efc1bbdab2da5881e70625ad97 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all task managers to finish initializing.  <a href="classhtgs_1_1_any_task_graph_conf.html#a5bb739efc1bbdab2da5881e70625ad97">More...</a><br /></td></tr>
<tr class="separator:a5bb739efc1bbdab2da5881e70625ad97 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cac65b5cd208123242d8214e4d5632 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">std::condition_variable *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a02cac65b5cd208123242d8214e4d5632">getInitializationCondition</a> ()</td></tr>
<tr class="memdesc:a02cac65b5cd208123242d8214e4d5632 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the task graph to check if all task managers have been initialized or not.  <a href="classhtgs_1_1_any_task_graph_conf.html#a02cac65b5cd208123242d8214e4d5632">More...</a><br /></td></tr>
<tr class="separator:a02cac65b5cd208123242d8214e4d5632 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da32a04e8e61c755b454ebc9fdf7d22 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">std::mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a7da32a04e8e61c755b454ebc9fdf7d22">getInitializationMutex</a> ()</td></tr>
<tr class="memdesc:a7da32a04e8e61c755b454ebc9fdf7d22 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initialization mutex, used for signaling when initialization is done.  <a href="classhtgs_1_1_any_task_graph_conf.html#a7da32a04e8e61c755b454ebc9fdf7d22">More...</a><br /></td></tr>
<tr class="separator:a7da32a04e8e61c755b454ebc9fdf7d22 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba09ea3f3dda89cd4301d6622c47d6e inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_any_task_graph_conf_8hpp.html#a2795477e4638b7ba72e6b6aa585cf325">TaskNameConnectorMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aeba09ea3f3dda89cd4301d6622c47d6e">getTaskConnectorNameMap</a> () const</td></tr>
<tr class="memdesc:aeba09ea3f3dda89cd4301d6622c47d6e inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task name connector map that maps the task name to its input connector.  <a href="classhtgs_1_1_any_task_graph_conf.html#aeba09ea3f3dda89cd4301d6622c47d6e">More...</a><br /></td></tr>
<tr class="separator:aeba09ea3f3dda89cd4301d6622c47d6e inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ade53ccf6a68e5a78a4859ded28787ed1">getCopy</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *orig)</td></tr>
<tr class="memdesc:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the copy for an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> based on some original <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> reference.  <a href="classhtgs_1_1_any_task_graph_conf.html#ade53ccf6a68e5a78a4859ded28787ed1">More...</a><br /></td></tr>
<tr class="separator:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8582a09620c0f9ff506965f44477e8 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a3b8582a09620c0f9ff506965f44477e8">getCopy</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *orig)</td></tr>
<tr class="memdesc:a3b8582a09620c0f9ff506965f44477e8 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the copy for an <a class="el" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. ">AnyITask</a> based on some original <a class="el" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. ">AnyITask</a> reference.  <a href="classhtgs_1_1_any_task_graph_conf.html#a3b8582a09620c0f9ff506965f44477e8">More...</a><br /></td></tr>
<tr class="separator:a3b8582a09620c0f9ff506965f44477e8 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_manager.html">TaskManager</a>&lt; T, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a955128064919d0284de0765aae41cfd3">getTaskManager</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *task)</td></tr>
<tr class="memdesc:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task manager that is responsible for a particular <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="classhtgs_1_1_any_task_graph_conf.html#a955128064919d0284de0765aae41cfd3">More...</a><br /></td></tr>
<tr class="separator:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0eb84a2a9990da8c11f353350bf489 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a1d0eb84a2a9990da8c11f353350bf489">addTaskManager</a> (<a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *taskManager)</td></tr>
<tr class="memdesc:a1d0eb84a2a9990da8c11f353350bf489 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a task manager to the task graph.  <a href="classhtgs_1_1_any_task_graph_conf.html#a1d0eb84a2a9990da8c11f353350bf489">More...</a><br /></td></tr>
<tr class="separator:a1d0eb84a2a9990da8c11f353350bf489 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0813fe216c48e7dad0dbf8008f0983f5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a id="a0813fe216c48e7dad0dbf8008f0983f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a0813fe216c48e7dad0dbf8008f0983f5">printProfile</a> ()</td></tr>
<tr class="memdesc:a0813fe216c48e7dad0dbf8008f0983f5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints profile data to console for all task managers. <br /></td></tr>
<tr class="separator:a0813fe216c48e7dad0dbf8008f0983f5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d80a4f7d1b1f672d9bdaffb4d7199 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a425d80a4f7d1b1f672d9bdaffb4d7199">getPipelineId</a> ()</td></tr>
<tr class="memdesc:a425d80a4f7d1b1f672d9bdaffb4d7199 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pipeline ID for the task graph configuration.  <a href="classhtgs_1_1_any_task_graph_conf.html#a425d80a4f7d1b1f672d9bdaffb4d7199">More...</a><br /></td></tr>
<tr class="separator:a425d80a4f7d1b1f672d9bdaffb4d7199 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86445492fc9421c0c5132bd608e2460 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ae86445492fc9421c0c5132bd608e2460">getNumPipelines</a> ()</td></tr>
<tr class="memdesc:ae86445492fc9421c0c5132bd608e2460 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pipelines that exist for this task graph.  <a href="classhtgs_1_1_any_task_graph_conf.html#ae86445492fc9421c0c5132bd608e2460">More...</a><br /></td></tr>
<tr class="separator:ae86445492fc9421c0c5132bd608e2460 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accab4a128de5b389716347a285aa9094 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094">writeDotToFile</a> (std::string file, int flags=0, std::string graphTitle=&quot;&quot;, std::string customTitleText=&quot;&quot;)</td></tr>
<tr class="memdesc:accab4a128de5b389716347a285aa9094 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the dot representation of the task graph to disk with additional options such as profiling.  <a href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094">More...</a><br /></td></tr>
<tr class="separator:accab4a128de5b389716347a285aa9094 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfd2aa56fe389eb612ce95e1b86cfba inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a9bfd2aa56fe389eb612ce95e1b86cfba">getAddress</a> ()</td></tr>
<tr class="memdesc:a9bfd2aa56fe389eb612ce95e1b86cfba inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address for the task graph.  <a href="classhtgs_1_1_any_task_graph_conf.html#a9bfd2aa56fe389eb612ce95e1b86cfba">More...</a><br /></td></tr>
<tr class="separator:a9bfd2aa56fe389eb612ce95e1b86cfba inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418e6384b4afa8d015d7ebe9ed2d1049 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a418e6384b4afa8d015d7ebe9ed2d1049">getNumberOfSubGraphs</a> () const</td></tr>
<tr class="memdesc:a418e6384b4afa8d015d7ebe9ed2d1049 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of sub graphs within this task graph.  <a href="classhtgs_1_1_any_task_graph_conf.html#a418e6384b4afa8d015d7ebe9ed2d1049">More...</a><br /></td></tr>
<tr class="separator:a418e6384b4afa8d015d7ebe9ed2d1049 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e75c93fcd58369fcd7b820b081f19f inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a40e75c93fcd58369fcd7b820b081f19f">getGraphComputeTime</a> () const</td></tr>
<tr class="memdesc:a40e75c93fcd58369fcd7b820b081f19f inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total time the graph was computing.  <a href="classhtgs_1_1_any_task_graph_conf.html#a40e75c93fcd58369fcd7b820b081f19f">More...</a><br /></td></tr>
<tr class="separator:a40e75c93fcd58369fcd7b820b081f19f inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed83cfe40e8564ea701470a63020cbab inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aed83cfe40e8564ea701470a63020cbab">getGraphCreationTime</a> () const</td></tr>
<tr class="memdesc:aed83cfe40e8564ea701470a63020cbab inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total time the graph was getting created.  <a href="classhtgs_1_1_any_task_graph_conf.html#aed83cfe40e8564ea701470a63020cbab">More...</a><br /></td></tr>
<tr class="separator:aed83cfe40e8564ea701470a63020cbab inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b405efa32fd885a3b82eca6fe4a42c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a id="af0b405efa32fd885a3b82eca6fe4a42c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#af0b405efa32fd885a3b82eca6fe4a42c">genDotGraphContent</a> (int flags)</td></tr>
<tr class="memdesc:af0b405efa32fd885a3b82eca6fe4a42c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the content only of the graph (excludes all graph definitions and attributes) <br /></td></tr>
<tr class="separator:af0b405efa32fd885a3b82eca6fe4a42c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62274b9980efe8a5a4a1187833345584 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a62274b9980efe8a5a4a1187833345584">copyTasks</a> (std::list&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *&gt; *tasks)</td></tr>
<tr class="memdesc:a62274b9980efe8a5a4a1187833345584 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of each task from the list of AnyTaskManagers passed as a parameter.  <a href="classhtgs_1_1_any_task_graph_conf.html#a62274b9980efe8a5a4a1187833345584">More...</a><br /></td></tr>
<tr class="separator:a62274b9980efe8a5a4a1187833345584 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4bd5dfbb48517acd389e18fa97960 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aebf4bd5dfbb48517acd389e18fa97960">getTaskManagerCopy</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *iTask)</td></tr>
<tr class="memdesc:aebf4bd5dfbb48517acd389e18fa97960 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task manager copy for a given <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="classhtgs_1_1_any_task_graph_conf.html#aebf4bd5dfbb48517acd389e18fa97960">More...</a><br /></td></tr>
<tr class="separator:aebf4bd5dfbb48517acd389e18fa97960 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e7dc6a67d31162ccd0fe0802cd10bf inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a70e7dc6a67d31162ccd0fe0802cd10bf">hasTask</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *task)</td></tr>
<tr class="memdesc:a70e7dc6a67d31162ccd0fe0802cd10bf inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is in the graph or not.  <a href="classhtgs_1_1_any_task_graph_conf.html#a70e7dc6a67d31162ccd0fe0802cd10bf">More...</a><br /></td></tr>
<tr class="separator:a70e7dc6a67d31162ccd0fe0802cd10bf inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a393e82c28c1a3ed0bd619f5ca51da5f9"><td class="memItemLeft" align="right" valign="top"><a id="a393e82c28c1a3ed0bd619f5ca51da5f9"></a>
std::list&lt; <a class="el" href="classhtgs_1_1_edge_descriptor.html">EdgeDescriptor</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a393e82c28c1a3ed0bd619f5ca51da5f9">edges</a></td></tr>
<tr class="memdesc:a393e82c28c1a3ed0bd619f5ca51da5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of edges for the graph, represented by edge descriptors to define how the edges are copied/added. <br /></td></tr>
<tr class="separator:a393e82c28c1a3ed0bd619f5ca51da5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6414c6eaf436982dfa9d75efdce0a157"><td class="memItemLeft" align="right" valign="top"><a id="a6414c6eaf436982dfa9d75efdce0a157"></a>
<a class="el" href="classhtgs_1_1_graph_edge.html">GraphEdge</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a6414c6eaf436982dfa9d75efdce0a157">graphConsumerEdge</a></td></tr>
<tr class="memdesc:a6414c6eaf436982dfa9d75efdce0a157"><td class="mdescLeft">&#160;</td><td class="mdescRight">The consumer accessing the TaskGraph's input connector. <br /></td></tr>
<tr class="separator:a6414c6eaf436982dfa9d75efdce0a157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f181d61eda92dd872d86fe19e556704"><td class="memItemLeft" align="right" valign="top"><a id="a0f181d61eda92dd872d86fe19e556704"></a>
std::list&lt; <a class="el" href="classhtgs_1_1_graph_edge.html">GraphEdge</a>&lt; U &gt; * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a0f181d61eda92dd872d86fe19e556704">graphProducerEdges</a></td></tr>
<tr class="memdesc:a0f181d61eda92dd872d86fe19e556704"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of producers that are outputting data to the TaskGraph's output connector. <br /></td></tr>
<tr class="separator:a0f181d61eda92dd872d86fe19e556704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c072839d748de933ae96371313dd52d"><td class="memItemLeft" align="right" valign="top"><a id="a9c072839d748de933ae96371313dd52d"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a9c072839d748de933ae96371313dd52d">input</a></td></tr>
<tr class="memdesc:a9c072839d748de933ae96371313dd52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input connector for the TaskGraph. <br /></td></tr>
<tr class="separator:a9c072839d748de933ae96371313dd52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6a48dc9c378889e2b48ca70e27776"><td class="memItemLeft" align="right" valign="top"><a id="a93f6a48dc9c378889e2b48ca70e27776"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a93f6a48dc9c378889e2b48ca70e27776">output</a></td></tr>
<tr class="memdesc:a93f6a48dc9c378889e2b48ca70e27776"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output connector for the TaskGraph. <br /></td></tr>
<tr class="separator:a93f6a48dc9c378889e2b48ca70e27776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class U&gt;<br />
class htgs::TaskGraphConf&lt; T, U &gt;</h3>

<p>Manages a group of connected ITasks and their connections. </p>
<p>Each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is added into the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> is stored in the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>'s metadata to allow for quick copying using <a class="el" href="classhtgs_1_1_task_graph_conf.html#a6885d5ddfcee1dadee68e5b9a586a0f1" title="Creates an exact copy of this task graph. ">copy()</a>.</p>
<p>The main methods for adding each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> into the graph are <a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01" title="Adds an edge to the graph, where one task produces data for a consumer task. ">addEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">addRuleEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">addMemoryManagerEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#a48dbeb77366351e99aabf1e34149855a" title="Adds a CudaMemoryManager edge with the specified name to the TaskGraphConf. ">addCudaMemoryManagerEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811" title="Sets the task that is consuming data from the input of the graph. ">setGraphConsumerTask()</a>, and <a class="el" href="classhtgs_1_1_task_graph_conf.html#a0857e5a678b01922a513cd2327114864" title="Sets the task that is producing data for the output of the graph. ">addGraphProducerTask()</a></p>
<p>When using these methods, the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> builds a <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">TaskManager</a>, which manages an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>. Parameters for customizing the thread pool, polling abilities, etc., are specified in the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> constructors: <a class="el" href="classhtgs_1_1_i_task.html#ac23fa74bf05d6a86000422d989ccc5d1" title="Creates an ITask with number of threads equal to 1. ">ITask::ITask()</a></p>
<p>Special memory edge functions are provided. For normal CPU memory edges use: <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">addMemoryManagerEdge()</a></p>
<p>For Cuda memory use: <a class="el" href="classhtgs_1_1_task_graph_conf.html#a48dbeb77366351e99aabf1e34149855a" title="Adds a CudaMemoryManager edge with the specified name to the TaskGraphConf. ">addCudaMemoryManagerEdge()</a></p>
<p>Every <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> has an input and output type (T and U). If a TaskGraph does not have an input or output type, then the data type can be specified as <a class="el" href="classhtgs_1_1_void_data.html" title="VoidData is used for data that is empty/void. ">VoidData</a>. There can be only one task consuming data from the graph. If multiple tasks need to process data from the input, then add a bookkeeper as the first task and rules to distribute data. There can be any number of tasks producing output data for the graph.</p>
<p>To add data into the input of a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef" title="Produces data for the input of the TaskGraph. ">produceData()</a> function. Once finished producing data for the graph, use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d" title="Decrements the input connector and wakes up any consumer of the graph&#39;s input if the input connector ...">finishedProducingData()</a> function to indicate a data input stream is is closing. If additional data streams are added as input for the graph, then use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a5d9a2ea9704c804e089c1794e1e8e664" title="Sets the input connector for the task graph. ">incrementGraphProducer()</a> function. By default a task graph starts with one producer for the graph for the main thread, if there are no producers (such as the first task in the graph begins processing immediately), then call <a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d" title="Decrements the input connector and wakes up any consumer of the graph&#39;s input if the input connector ...">finishedProducingData()</a>.</p>
<p>To process the output of a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676" title="Consumes data from the output of a TaskGraph. ">consumeData()</a> function. To determine if data is no longer being produced by a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea" title="Checks if the output of the TaskGraph has finished producing data. ">isOutputTerminated()</a> function. The output of the consumeData function could produce nullptr data when the graph is closing.</p>
<p>Example Usage: </p><div class="fragment"><div class="line"><a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixBlockRequest, MatrixBlockRequest&gt;</a> *taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixBlockRequest, MatrixBlockRequest&gt;</a>();</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> numLoadThreads = 2;</div><div class="line"><span class="keywordtype">int</span> numMulThreads = 20;</div><div class="line"></div><div class="line">LoadMatrixTask *loadMatrixTask = <span class="keyword">new</span> LoadMatrixTask(numLoadThreads, blockSize, width, height);</div><div class="line">ScalarMultiplyTask *scalMulTask = <span class="keyword">new</span> ScalarMultiplyTask(numMulThreads, blockSize, width, height);</div><div class="line"><a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&gt;</a> *bkTask = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&gt;</a>();</div><div class="line"></div><div class="line">MatrixLoadRule *loadRule = <span class="keyword">new</span> MatrixLoadRule(width/blockSize, height/blockSize);</div><div class="line"></div><div class="line"><span class="comment">// Add tasks to graph</span></div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01">addEdge</a>(loadMatrixTask, bkTask);</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274">addRuleEdge</a>(bkTask, loadRule, scalMulTask);</div><div class="line"></div><div class="line"><span class="comment">// Add memory edges</span></div><div class="line">MatrixAllocator *matrixAlloc = <span class="keyword">new</span> MatrixAllocator(blockSize, blockSize);</div><div class="line"><span class="keywordtype">int</span> poolSize = 50;</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb">addMemoryManagerEdge</a>(<span class="stringliteral">&quot;MatrixA&quot;</span>, loadMatrixTask, matrixAlloc, 50);</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb">addMemoryManagerEdge</a>(<span class="stringliteral">&quot;MatrixB&quot;</span>, loadMatrixTask, matrixAlloc, 50);</div><div class="line"></div><div class="line"><span class="comment">// Setup graph input/output</span></div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811">setGraphConsumerTask</a>(loadMatrixTask);</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a0857e5a678b01922a513cd2327114864">addGraphProducerTask</a>(scalMulTask);</div><div class="line"></div><div class="line"><span class="comment">// Setup runtime and execute</span></div><div class="line"><a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a> *runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a>(taskGraph);</div><div class="line">runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9">executeRuntime</a>();</div><div class="line"></div><div class="line"><span class="comment">// Add input to graph</span></div><div class="line"><span class="keywordflow">for</span> (blockRow = 0; blockRow &lt; blockHeight; blockRow++)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span>(blockCol = 0; blockCol &lt; blockWidth; blockCol++)</div><div class="line">  {</div><div class="line">    <span class="comment">// Request to multiply BlockedA[blockRow, blockCol] .* BlockedB[blockRow, blockCol]</span></div><div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef">produceData</a>(<span class="keyword">new</span> MatrixBlockRequest(blockRow, blockCol, <span class="stringliteral">&quot;MatrixA&quot;</span>));</div><div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef">produceData</a>(<span class="keyword">new</span> MatrixBlockRequest(blockRow, blockCol, <span class="stringliteral">&quot;MatrixB&quot;</span>));</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Indicate finished producing data</span></div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d">finishedProducingData</a>();</div><div class="line"></div><div class="line"><span class="comment">// Process taskGraph output</span></div><div class="line"><span class="keywordflow">while</span> (!taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea">isOutputTerminated</a>())</div><div class="line">{</div><div class="line">  std::shared_ptr&lt;MatrixBlockRequest&gt; mbr = taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676">consumeData</a>();</div><div class="line">  <span class="keywordflow">if</span> (mbr != <span class="keyword">nullptr</span>)</div><div class="line">  {</div><div class="line">    <span class="comment">// ... apply post-processing</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a8f2eaf040695178b6f61db7b0ee16c89">waitForRuntime</a>();</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input data type for the TaskGraph, T must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
    <tr><td class="paramname">U</td><td>the output data type for the TaskGraph, U must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adce9d842849be607b3ef2626eedff2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce9d842849be607b3ef2626eedff2f9">&#9670;&nbsp;</a></span>TaskGraphConf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::<a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a TaskGraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipelineId for this graph </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of pipelines for the graph </td></tr>
    <tr><td class="paramname">baseAddress</td><td>the base address for the task graph to build upon for multiple levels of execution pipelines </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a48dbeb77366351e99aabf1e34149855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dbeb77366351e99aabf1e34149855a">&#9670;&nbsp;</a></span>addCudaMemoryManagerEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class IMemoryAllocatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addCudaMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IMemoryAllocatorType &gt;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>gpuIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<p>This will create a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> that is bound to some Cuda GPU based on the pipelineId of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
    <tr><td class="paramname">gpuIds</td><td>the array Cuda GPU Ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the GPU if the allocator-&gt;size() * memoryPoolSize exceeds the total GPU memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e. 'cufftDoubleComplex *' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854ec9f27f6c9c423b1090aa9910fbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854ec9f27f6c9c423b1090aa9910fbff">&#9670;&nbsp;</a></span>addCudaMemoryManagerEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addCudaMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>gpuIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<p>This will create a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> that is bound to some Cuda GPU based on the pipelineId of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager e </td></tr>
    <tr><td class="paramname">gpuIdsthe</td><td>array of requested GPU Ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the GPU if the allocator-&gt;size() * memoryPoolSize exceeds the total GPU memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e. 'cufftDoubleComplex *' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e01d687d11fcd4a7c9bd90f8f65a7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e01d687d11fcd4a7c9bd90f8f65a7f3">&#9670;&nbsp;</a></span>addCustomMemoryManagerEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addCustomMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_memory_manager.html">MemoryManager</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>memoryManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a custom <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<p>This will create a custom memory manager </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">getMemoryTask</td><td></td></tr>
    <tr><td class="paramname">memoryManager</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaf80f060f13a40b41579a8678acad01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf80f060f13a40b41579a8678acad01">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class W , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; V, W &gt; *&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the graph, where one task produces data for a consumer task. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the input type for the producer task </td></tr>
    <tr><td class="paramname">W</td><td>the output/input types for the producer/consumer tasks </td></tr>
    <tr><td class="paramname">X</td><td>the output type for the consumer task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>the task that is producing data </td></tr>
    <tr><td class="paramname">consumer</td><td>the task that consumes the data from the producer task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0857e5a678b01922a513cd2327114864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0857e5a678b01922a513cd2327114864">&#9670;&nbsp;</a></span>addGraphProducerTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addGraphProducerTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, U &gt; *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the task that is producing data for the output of the graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">W</td><td>the input type of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task that produces data that is added as output for the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>There can be multiple tasks that produces for the graph. </dd></dl>

</div>
</div>
<a id="a88adcd11f63ba49703f82f1210d0f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88adcd11f63ba49703f82f1210d0f0eb">&#9670;&nbsp;</a></span>addMemoryManagerEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class IMemoryAllocatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IMemoryAllocatorType &gt;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if the rule connecting the bookkeeper and consumer are shared among multiple graphs that you create. </dd></dl>

</div>
</div>
<a id="a442420d2c9c115ca9f9c644f7e5c985f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442420d2c9c115ca9f9c644f7e5c985f">&#9670;&nbsp;</a></span>addMemoryManagerEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedfc932815a7b264da00c35d274f5274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfc932815a7b264da00c35d274f5274">&#9670;&nbsp;</a></span>addRuleEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class IRuleType , class W , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addRuleEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>bookkeeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IRuleType &gt;&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rule edge that is managed by a bookkeeper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the input type for the bookkeeper and rule </td></tr>
    <tr><td class="paramname">IRuleType</td><td>the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a> that determines when to produce data for the edge (must match the input types of both the bookkeeper and the consumer task) </td></tr>
    <tr><td class="paramname">W</td><td>the output/input type for the rule/consumer task </td></tr>
    <tr><td class="paramname">X</td><td>the output type for the consumer task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bookkeeper</td><td>the bookkeeper task that manages this edge </td></tr>
    <tr><td class="paramname">rule</td><td>the rule that determines when to produce data for the edge </td></tr>
    <tr><td class="paramname">consumer</td><td>the consumer of the rule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if the rule connecting the bookkeeper and consumer are shared among multiple graphs that you create. </dd></dl>

</div>
</div>
<a id="ac3d41cc1d73dfda04f8f9ab48a525980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d41cc1d73dfda04f8f9ab48a525980">&#9670;&nbsp;</a></span>addRuleEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class W , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addRuleEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>bookkeeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; *&#160;</td>
          <td class="paramname"><em>iRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rule edge that is managed by a bookkeeper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the input type for the bookkeeper and rule </td></tr>
    <tr><td class="paramname">W</td><td>the output/input type for the rule/consumer task </td></tr>
    <tr><td class="paramname">X</td><td>the output type for the consumer task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bookkeeper</td><td>the bookkeeper task that manages this edge </td></tr>
    <tr><td class="paramname">iRule</td><td>the rule that determines when to produce data for the edge </td></tr>
    <tr><td class="paramname">consumer</td><td>the consumer of the rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8fa554c295c9ff11fde6b3473d53676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fa554c295c9ff11fde6b3473d53676">&#9670;&nbsp;</a></span>consumeData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;U&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::consumeData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumes data from the output of a TaskGraph. </p>
<p>It is possible for consumeData to return nullptr if the last Task has finished. Therefore, when consuming data from a TaskGraph it is important to have a check for nullptr prior to processing that data. </p><dl class="section return"><dt>Returns</dt><dd>one data element from the output of the TaskGraph or nullptr if the last task is closing. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The task producing data for the TaskGraph will send nullptr to the connector, so the thread consuming data should check for nullptr prior to processing the data. </dd></dl>

</div>
</div>
<a id="a6885d5ddfcee1dadee68e5b9a586a0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6885d5ddfcee1dadee68e5b9a586a0f1">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html">AnyTaskGraphConf</a>* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an exact copy of this task graph. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the task graph. </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aaedf378d624b872042d093017c8ad8ab">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a id="a163409dd38587f67b49502835ca107fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163409dd38587f67b49502835ca107fe">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipeline Id </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of pipelines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the copy of the task graph </dd></dl>

</div>
</div>
<a id="a538400eab48faf2e6ca2f12eee77f86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538400eab48faf2e6ca2f12eee77f86c">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt;&gt;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines, and updates the input and output connectors for the graph copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipeline Id </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of pipelines </td></tr>
    <tr><td class="paramname">input</td><td>the input connector to be used for the graph's input </td></tr>
    <tr><td class="paramname">output</td><td>the output connector to be used for the graph's output </td></tr>
    <tr><td class="paramname">baseAddress</td><td>the base address for the task graph to build upon for multiple levels of execution pipelines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the copy of the task graph </dd></dl>

</div>
</div>
<a id="a329871e557370e432de17e9edb3de39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329871e557370e432de17e9edb3de39f">&#9670;&nbsp;</a></span>createExecutionPipeline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_execution_pipeline.html">ExecutionPipeline</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::createExecutionPipeline </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;Execution&#160;Pipeline&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForInit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps this task graph into an execution pipeline task, which will then be used to duplicate and execute across multiple GPUs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numPipelines</td><td>the number of pipeline to spawn </td></tr>
    <tr><td class="paramname">waitForInit</td><td>Waits for all tasks in the graphs to finish initializing before the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> returns from its initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the execution pipeline task </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In order to decompose data to each pipeline, you must add rules to the execution pipeline task. </dd>
<dd>
Do not interact with or alter this <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> after the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> has been launched using a <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">TaskGraphRuntime</a>. </dd></dl>

</div>
</div>
<a id="aa9e5a3f38042c8f2508c83865c578426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e5a3f38042c8f2508c83865c578426">&#9670;&nbsp;</a></span>createTaskGraphTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_t_g_task.html">TGTask</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::createTaskGraphTask </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;TGTask&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForInit</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps this task graph into a <a class="el" href="classhtgs_1_1_t_g_task.html" title="TGTask is the task graph task, which is used to bundle a graph as a task, which can then be connected...">TGTask</a>. </p>
<p>This will improve visualization of multiple graphs that interact with eachother. In addition the input/outputs of the <a class="el" href="classhtgs_1_1_t_g_task.html" title="TGTask is the task graph task, which is used to bundle a graph as a task, which can then be connected...">TGTask</a>, as connected in a new graph, will be incorporated into the task graph you use with the <a class="el" href="classhtgs_1_1_t_g_task.html" title="TGTask is the task graph task, which is used to bundle a graph as a task, which can then be connected...">TGTask</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitForInit</td><td>Waits for all tasks in the graph to finish initializing before the <a class="el" href="classhtgs_1_1_t_g_task.html" title="TGTask is the task graph task, which is used to bundle a graph as a task, which can then be connected...">TGTask</a> returns from its initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the task graph task </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Do not interact with or alter this <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> after the <a class="el" href="classhtgs_1_1_t_g_task.html" title="TGTask is the task graph task, which is used to bundle a graph as a task, which can then be connected...">TGTask</a> has been launched. </dd>
<dd>
Do not produce data into the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> that was used with the <a class="el" href="classhtgs_1_1_t_g_task.html" title="TGTask is the task graph task, which is used to bundle a graph as a task, which can then be connected...">TGTask</a>. </dd></dl>

</div>
</div>
<a id="a8ce4d72dc9c5ad94762d75778dfc650f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce4d72dc9c5ad94762d75778dfc650f">&#9670;&nbsp;</a></span>debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides debug output for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<dl class="section note"><dt>Note</dt><dd>#define DEBUG_FLAG to enable debugging </dd></dl>

</div>
</div>
<a id="a2c1e54bfce0472b38d422f973d3ba68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1e54bfce0472b38d422f973d3ba68d">&#9670;&nbsp;</a></span>finishedProducingData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::finishedProducingData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements the input connector and wakes up any consumer of the graph's input if the input connector is finished producing data. </p>
<dl class="section note"><dt>Note</dt><dd>This should be called by the main thread when all data is finished being produced for this task graph. </dd></dl>

</div>
</div>
<a id="adb21b53a773e25473385e0bc714a6677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb21b53a773e25473385e0bc714a6677">&#9670;&nbsp;</a></span>genCustomDotForTasks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::genCustomDotForTasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_profile_utils.html">ProfileUtils</a> *&#160;</td>
          <td class="paramname"><em>profileUtils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colorFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the custom dot profiles for all tasks in this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileUtils</td><td>the profile utils for color coding tasks </td></tr>
    <tr><td class="paramname">colorFlag</td><td>the color flag that was specified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the additional custom dot file content </dd></dl>

</div>
</div>
<a id="a5dd8e80fa9e22331d702683c3ebf5fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd8e80fa9e22331d702683c3ebf5fda">&#9670;&nbsp;</a></span>genDotGraphEdgesWithoutConnectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::genDotGraphEdgesWithoutConnectors </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *, <a class="el" href="classhtgs_1_1_task_manager_profile.html">TaskManagerProfile</a> *&gt; *&#160;</td>
          <td class="paramname"><em>allTaskManagerProfiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the edges between tasks without connectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allTaskManagerProfiles</td><td>all of the task managers for all graphs and its sub-graphs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot representation of the connection between task managers </dd></dl>

</div>
</div>
<a id="abefecdde12a738f08e41f410015afb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefecdde12a738f08e41f410015afb6e">&#9670;&nbsp;</a></span>getInputConnector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a>&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::getInputConnector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that gets the task manager that is consuming data from the graph's input. </p>
<dl class="section return"><dt>Returns</dt><dd>the task manager that is consuming data from the graph's input. Gets the list of task managers that are producing data for the graph's output </dd>
<dd>
the list of task managers that are producing data for the graph's output. Virtual function that gets the connector used for graph input </dd>
<dd>
the connector used for graph input </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a56173dc596a66b2f186b3471c412706a">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a id="a2d3a06907ead06a968ab1530922a0ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3a06907ead06a968ab1530922a0ea2">&#9670;&nbsp;</a></span>getOutputConnector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a>&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::getOutputConnector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that gets the connector used for graph output. </p>
<dl class="section return"><dt>Returns</dt><dd>the connector used for graph output </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aab64ec2f1dfebbea602daeb0280c5030">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a id="a5d9a2ea9704c804e089c1794e1e8e664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9a2ea9704c804e089c1794e1e8e664">&#9670;&nbsp;</a></span>incrementGraphProducer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::incrementGraphProducer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input connector for the task graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input connector Sets the output connector for the task graph </td></tr>
    <tr><td class="paramname">output</td><td>the output connector Increments the number of producers for the task graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input connector is automatically incremented when creating a graph, so this should only be called if additional sources will be producing data other than the main function. </dd></dl>

</div>
</div>
<a id="acdbd07f1ea2ee2afb70665f5873407ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbd07f1ea2ee2afb70665f5873407ea">&#9670;&nbsp;</a></span>isOutputTerminated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::isOutputTerminated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the output of the TaskGraph has finished producing data. </p>
<dl class="section return"><dt>Returns</dt><dd>whether the output is finished or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the output is no longer producing data </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the output is not finished producing data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ec690fd65d8cc54c0631f1a813bb07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec690fd65d8cc54c0631f1a813bb07c">&#9670;&nbsp;</a></span>pollData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;U&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::pollData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>microTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls for data from the output of the TaskGraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microTimeout</td><td>the timeout time in microseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data or nullptr if the timeout period expires. </dd></dl>

</div>
</div>
<a id="a834c5f5f07d3cceac5d7f6f9e128e7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834c5f5f07d3cceac5d7f6f9e128e7ef">&#9670;&nbsp;</a></span>produceData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces data for the input of the TaskGraph. </p>
<p>Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being added to the TaskGraph input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data being passed will be wrapped into a std::shared_ptr&lt;T&gt;(data) </dd></dl>

</div>
</div>
<a id="a614839d80ed96f8938d38606e895225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614839d80ed96f8938d38606e895225a">&#9670;&nbsp;</a></span>produceData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces data for the input of the TaskGraph. </p>
<p>Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being added to the TaskGraph input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a054eb3b880cd8935d9bfad3a42e1c274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054eb3b880cd8935d9bfad3a42e1c274">&#9670;&nbsp;</a></span>produceData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::shared_ptr&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dataList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of data into the TaskGraph Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataList</td><td>the list of data to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87ea35e80b6f26adaefed94f09598ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ea35e80b6f26adaefed94f09598ef7">&#9670;&nbsp;</a></span>releaseMemory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::releaseMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">m_data_t</a>&lt; V &gt;&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases memory back to its memory manager. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The m_data_t must have originated within this task graph. </dd></dl>

</div>
</div>
<a id="a23520b3b3054e16c59784b0d3a289811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23520b3b3054e16c59784b0d3a289811">&#9670;&nbsp;</a></span>setGraphConsumerTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::setGraphConsumerTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, W &gt; *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the task that is consuming data from the input of the graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">W</td><td>the output type of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task that consumes data that is added into the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only one task consumes data from the graph. If multiple tasks need data from the graph, then a bookkeeper should be added to distribute data among the multiple tasks. </dd></dl>

</div>
</div>
<a id="abc328ee2d85ab7841d3d608f2379b313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc328ee2d85ab7841d3d608f2379b313">&#9670;&nbsp;</a></span>setInputConnector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::setInputConnector </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td>
          <td class="paramname"><em>connector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input connector for the task graph configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connector</td><td>the input connector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c770403588c32b77f7ffbfdb0474df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c770403588c32b77f7ffbfdb0474df0">&#9670;&nbsp;</a></span>setOutputConnector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::setOutputConnector </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td>
          <td class="paramname"><em>connector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the output connector for the task graph configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connector</td><td>the output connector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adea9cf75785a9ab08bd5333062714e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea9cf75785a9ab08bd5333062714e45">&#9670;&nbsp;</a></span>updateTaskManagersAddressingAndPipelines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::updateTaskManagersAddressingAndPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the task managers addresses, pipelineIds and the number of pipelines for all tasks in the TaskGraph. </p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called by the HTGS API </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a7eb5e49c942eea1a2bc0bc0a7302fb93">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/tjb3/work/HTGS/src/htgs/api/<a class="el" href="_execution_pipeline_8hpp_source.html">ExecutionPipeline.hpp</a></li>
<li>/home/tjb3/work/HTGS/src/htgs/api/<a class="el" href="_task_graph_conf_8hpp_source.html">TaskGraphConf.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>htgs</b></li><li class="navelem"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
