<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: Tutorial 2B</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial2b.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 2B </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut2b-objectives">Objectives </a></li>
<li class="level1"><a href="#tut2b-api-used">API Used </a></li>
<li class="level1"><a href="#tut2b-implementation">Implementation </a><ul><li class="level2"><a href="#tut2b-data">Data</a></li>
<li class="level2"><a href="#tut2b-tasks">Tasks</a><ul><li class="level3"><a href="#tut2b-read-matrix-task">ReadDiskMatrixTask</a></li>
<li class="level3"><a href="#tut2b-hadamard-product-task">HadamardProductTaskWithReleaseMem</a></li>
<li class="level3"><a href="#tut2b-task-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut2b-bookkeeper">Managing Dependencies with a Bookkeeper and IRules</a></li>
<li class="level2"><a href="#tut2b-memory-manager">Throttling Tasks with a Memory Manager</a><ul><li class="level3"><a href="#tut2b-static-mm">Static Memory Manager</a></li>
<li class="level3"><a href="#tut2b-dynamic-mm">Dynamic Memory Manager</a></li>
<li class="level3"><a href="#tut2b-matrix-allocator">MatrixAllocator</a></li>
<li class="level3"><a href="#tut2b-matrix-memory-rule">MatrixMemoryRule</a></li>
<li class="level3"><a href="#tut2b-memorymanagement-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut2b-create-and-execute-taskgraph">Creating and Executing the TaskGraph</a><ul><li class="level3"><a href="#tut2b-main-function">Main function (Hadamard Product)</a></li>
<li class="level3"><a href="#tut2b-taskgraph-notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#tut2b-summary">Summary </a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we expand on <a class="el" href="tutorial2a.html">Tutorial 2A</a> by adding two components to the previous task graph: (1) Reading the matrices from disk and (2) Using memory managers to stay within memory limits.</p>
<p>The source code for the tutorial is found <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial2/with-disk">here</a>.</p>
<h1><a class="anchor" id="tut2b-objectives"></a>
Objectives </h1>
<ol type="1">
<li>How to pipeline tasks<ul>
<li>With the goal of overlapping I/O with compute</li>
</ul>
</li>
<li>How to manage memory</li>
<li>How to handle memory between a TaskGraph's task and the main thread</li>
</ol>
<h1><a class="anchor" id="tut2b-api-used"></a>
API Used </h1>
<ul>
<li>&lt;<a class="el" href="_i_data_8hpp.html" title="Implements the IData class, which is used for all data types entering/leaving a task graph...">htgs/api/IData.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_task_8hpp.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs/api/ITask.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_conf_8hpp.html" title="Implements the task graph configuration class responsible for managing ITask connections. ">htgs/api/TaskGraphConf.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_runtime_8hpp.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs/api/TaskGraphRuntime.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_memory_data_8hpp.html" title="Implements MemoryData used by a MemoryManager, which can be shared among multiple ITask...">htgs/api/MemoryData.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_memory_allocator_8hpp.html" title="Defines how memory is allocated and freed. ">htgs/api/IMemoryAllocator.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_memory_release_rule_8hpp.html" title="Describes how memory is released. ">htgs/api/IMemoryReleaseRule.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_rule_8hpp.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs/api/IRule.hpp</a>&gt;</li>
</ul>
<h1><a class="anchor" id="tut2b-implementation"></a>
Implementation </h1>
<p>This tutorial uses the same algorithm and representation for the Hadamard product presented in <a class="el" href="tutorial2a.html#tut2a-implementation">Tutorial2A Implementation</a>.</p>
<p>The primary change is altering the generate matrix task to read from disk and add support for systems with limited memory. This is particularly useful if the full matrix does not fit into system memory. To incorporate this design, we annotate the graph to include memory edges.</p>
<div class="image">
<img src="tut2Hadamard-taskgraph.png" alt="tut2Hadamard-taskgraph.png"/>
<div class="caption">
Original task graph from Tutorial 2A</div></div>
<p><br />
<br />
 </p><div class="image">
<img src="tut2Hadamard-taskgraph-memory.png" alt="tut2Hadamard-taskgraph-memory.png"/>
<div class="caption">
Task graph with annotated memory edges</div></div>
<p> Using the memory edges, we are able to ensure that a fixed number of block-sized matrices flow through the graph, staying within memory limits. The memory is allocated using the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>. A <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> is specified to determine when the memory can be released. For the Hadamard product, this rule is trivial because the memory can be released as soon as the data has been used for computation. In more complex examples, such as matrix multiplication (<a class="el" href="tutorial3a.html">Tutorial 3</a>), data reuse must be carefully analyzed to ensure that the system does not deadlock; i.e. the memory never gets released because its release rule cannot be satisfied based on the traversal of data. The way an algorithm uses its data is important to understand to optimize these release rules, which ideally keeps data close to its processor for as long as possible.</p>
<p>The Hadamard product with memory management creates three memory edges for the two input matrices and the output matrix. In the pictoral representation, we mark that the Hadamard product task releases the memory for matrices A and B. Matrix C has a floating edge indicating that the memory will be released elsewhere. In actuality, the HTGS API only specifies the task that is allocating memory. This will be described in further detail later on in this tutorial.</p>
<h2><a class="anchor" id="tut2b-data"></a>
Data</h2>
<p>This tutorial uses the same data as presented in <a class="el" href="tutorial2a.html#tut2a-data">Tutorial 2A Data</a>.</p>
<h2><a class="anchor" id="tut2b-tasks"></a>
Tasks</h2>
<p>This tutorial uses the same tasks as in <a class="el" href="tutorial2a.html#tut2a-tasks">Tutorial 2A tasks</a>, except the Hadamard product task will now get and release memory with the <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> and <a class="el" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba" title="Releases memory onto a memory edge, which is transferred by the graph communicator. ">htgs::ITask::releaseMemory</a> functions. Also, we will modify the GenMatrixTask to read the data from disk.</p>
<p>The ReadDiskMatrixTask is responsible for reading matrices A or B depending on the type of MatrixRequestData passed to the read task. The matrix data is loaded from disk such that each block has its own file. If a new block size is specified, then the matrix data will have to be regenerated. There are multiple techniques for reading blocks of data, such as using memory mapped files and optimized file formats for specifying sub-regions without reading the entire file. In the next tutorial, we will show how to use memory mapped files for I/O (Linux/MacOS only), which can be used to improve bandwidth.</p>
<p>The directory structure for the data is stored as follows: "data/tutorial2/4096x4096blksize1024/matrix&lt;A/B&gt;". Prior to reading data from disk, the ReadDiskMatrixTask allocates from main memory to store the data. This memory is acquired from a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> for matrix A or matrix B. To get memory from the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>, we use the <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> function with the name of the memory edge and the release rule that is associated with the memory. The release rule is used to identify when the memory can be recycled. This allows for the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> to express how it plans on using the data and ideally can be setup to only have to load the data once and release once all computation is done for that data. If the data were to be released prior to all computation being done, then a loop would need to be created (such as adding a new <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> with the appropriate <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> edge) to load the data a second time from disk. If a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> calls <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> and it had not declared the name of the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> for the edge, then the program will report an assertion failed or segmentation fault. To check if a memory edge exists use <a class="el" href="classhtgs_1_1_any_i_task.html#a7a2a3413aba1c422531a94a1177c7477" title="Checks whether this ITask contains a memory edge for a specified name. ">htgs::ITask::hasMemoryEdge</a>.</p>
<p>The matrices can be created and saved to disk using the tutorial-utils function: <a href="https://github.com/usnistgov/HTGS-Tutorials/blob/master/tutorial-utils/util-matrix.cpp">checkAndValidateMatrixBlockFiles</a>, which will check to see if all the necessary files are available on disk, and generate them if any are missing.</p>
<p>The HadamardProductTaskWithReleaseMem is responsible for the scalar product of two matrices. These matrices are stored in the MatrixBlockMulData object. Prior to multiplying the matrices, the task allocates memory for the resulting matrix, which will be added to the output of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<p>After the Hadamard product task has completed processing matrices A and B together, the task must release the memory so that the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> can recycle that memory for the read task. Releasing memory is done using the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> (or htgs::m_data_t from &lt;<a class="el" href="_types_8hpp.html" title="Defines common types used throughout the HTGS API and some of which that are used by users of HTGS su...">htgs/types/Types.hpp</a>&gt;) that was received from <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a>, which is passed to the <a class="el" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba" title="Releases memory onto a memory edge, which is transferred by the graph communicator. ">htgs::ITask::releaseMemory</a> function. The htgs::m_data_t contains metadata, which describes where the memory was allocated, allowing the memory to return to its corresponding memory manager. The main stipulation with using this functionality is that all memory managers in a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> must have unique names (the names of the edges) and that the memory was allocated in the same graph that it is released.</p>
<p>In the ReadDiskMatrixTask we use the <a href="https://github.com/usnistgov/HTGS-Tutorials/blob/master/tutorial-utils/enums/MatrixType.cpp">matrixTypeToString</a> function to convert the matrix type enum to a string representation. This implementation is found in the enums folder in tutorial-utils.</p>
<h3><a class="anchor" id="tut2b-read-matrix-task"></a>
ReadDiskMatrixTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixRequestData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../rules/MatrixMemoryRule.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../enums/MatrixType.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>ReadDiskMatrixTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixRequestData, MatrixBlockData&lt;htgs::m_data_t&lt;double&gt;&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  ReadDiskMatrixTask(<span class="keywordtype">size_t</span> numThreads, <span class="keywordtype">size_t</span> blockSize, <span class="keywordtype">size_t</span> fullMatrixWidth, <span class="keywordtype">size_t</span> fullMatrixHeight, std::string directory, MatrixType matrixType, <span class="keywordtype">bool</span> computeReleaseCount) :</div><div class="line">      ITask(numThreads),</div><div class="line">      blockSize(blockSize),</div><div class="line">      fullMatrixHeight(fullMatrixHeight),</div><div class="line">      fullMatrixWidth(fullMatrixWidth),</div><div class="line">      directory(directory),</div><div class="line">      matrixType(matrixType),</div><div class="line">      computeReleaseCount(computeReleaseCount)</div><div class="line">  {</div><div class="line">    numBlocksRows = (size_t) ceil((<span class="keywordtype">double</span>) fullMatrixHeight / (double) blockSize);</div><div class="line">    numBlocksCols = (size_t) ceil((<span class="keywordtype">double</span>) fullMatrixWidth / (double) blockSize);</div><div class="line">    <span class="keywordflow">if</span> (computeReleaseCount)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">switch</span>(matrixType)</div><div class="line">      {</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> MatrixType::MatrixA:</div><div class="line">          releaseCount = numBlocksCols;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> MatrixType::MatrixB:</div><div class="line">          releaseCount = numBlocksRows;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> MatrixType::MatrixC:<span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> MatrixType::MatrixAny:<span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    } <span class="keywordflow">else</span>{</div><div class="line">      releaseCount = 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~ReadDiskMatrixTask() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixRequestData&gt; data) {</div><div class="line">    std::string matrixName = matrixTypeToString(data-&gt;getType());</div><div class="line"></div><div class="line">    <a class="code" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">htgs::m_data_t&lt;double&gt;</a> matrixData = this-&gt;getMemory&lt;double&gt;(matrixName, <span class="keyword">new</span> MatrixMemoryRule(releaseCount));</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> row = data-&gt;getRow();</div><div class="line">    <span class="keywordtype">size_t</span> col = data-&gt;getCol();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> matrixWidth;</div><div class="line">    <span class="keywordtype">size_t</span> matrixHeight;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (col == numBlocksCols - 1 &amp;&amp; fullMatrixWidth % blockSize != 0)</div><div class="line">      matrixWidth = fullMatrixWidth % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixWidth = blockSize;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (row == numBlocksRows - 1 &amp;&amp; fullMatrixHeight % blockSize != 0)</div><div class="line">      matrixHeight = fullMatrixHeight % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixHeight = blockSize;</div><div class="line"></div><div class="line">    std::string fileName(directory + <span class="stringliteral">&quot;/&quot;</span> + matrixName + <span class="stringliteral">&quot;/&quot;</span> + std::to_string(row) + <span class="stringliteral">&quot;_&quot;</span> + std::to_string(col));</div><div class="line"></div><div class="line">    <span class="comment">// Read data</span></div><div class="line">    std::ifstream file(fileName, std::ios::binary);</div><div class="line"></div><div class="line">    file.read((<span class="keywordtype">char</span> *) matrixData-&gt;get(), <span class="keyword">sizeof</span>(double) * matrixWidth * matrixHeight);</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;<a class="code" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">htgs::m_data_t&lt;double&gt;</a>&gt;(data, matrixData, matrixWidth, matrixHeight, matrixWidth));</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ReadDiskMatrixTask(&quot;</span> + matrixTypeToString(matrixType) + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> ReadDiskMatrixTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ReadDiskMatrixTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>(), blockSize, fullMatrixWidth, fullMatrixHeight, directory, matrixType, computeReleaseCount);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> getNumBlocksRows()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksRows;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> getNumBlocksCols()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksCols;</div><div class="line">  }</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">size_t</span> blockSize;</div><div class="line">  <span class="keywordtype">size_t</span> fullMatrixWidth;</div><div class="line">  <span class="keywordtype">size_t</span> fullMatrixHeight;</div><div class="line">  <span class="keywordtype">size_t</span> numBlocksRows;</div><div class="line">  <span class="keywordtype">size_t</span> numBlocksCols;</div><div class="line">  std::string directory;</div><div class="line">  MatrixType matrixType;</div><div class="line">  <span class="keywordtype">bool</span> computeReleaseCount;</div><div class="line">  <span class="keywordtype">size_t</span> releaseCount;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut2b-hadamard-product-task"></a>
HadamardProductTaskWithReleaseMem</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../../../tutorial-utils/matrix-library/data/MatrixBlockMulData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>HadamardProductTaskWithReleaseMem : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixBlockMulData&lt;htgs::m_data_t&lt;double&gt;&gt;, MatrixBlockData&lt;htgs::m_data_t&lt;double&gt;&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  HadamardProductTaskWithReleaseMem(<span class="keywordtype">size_t</span> numThreads) : ITask(numThreads) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~HadamardProductTaskWithReleaseMem() { }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixBlockMulData&lt;<a class="code" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">htgs::m_data_t&lt;double&gt;</a>&gt;&gt; data) {</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matAData = data-&gt;getMatrixA();</div><div class="line">    <span class="keyword">auto</span> matBData = data-&gt;getMatrixB();</div><div class="line"></div><div class="line">    <a class="code" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">htgs::m_data_t&lt;double&gt;</a> matrixA = matAData-&gt;getMatrixData();</div><div class="line">    <a class="code" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">htgs::m_data_t&lt;double&gt;</a> matrixB = matBData-&gt;getMatrixData();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> width = matAData-&gt;getMatrixWidth();</div><div class="line">    <span class="keywordtype">size_t</span> height = matAData-&gt;getMatrixHeight();</div><div class="line"></div><div class="line">    <a class="code" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">htgs::m_data_t&lt;double&gt;</a> result = this-&gt;getMemory&lt;double&gt;(<span class="stringliteral">&quot;result&quot;</span>, <span class="keyword">new</span> MatrixMemoryRule(1));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; matAData-&gt;getMatrixWidth() * matAData-&gt;getMatrixHeight(); i++) {</div><div class="line">      result-&gt;get()[i] = matrixA-&gt;get(i) * matrixB-&gt;get(i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matRequest = matAData-&gt;getRequest();</div><div class="line"></div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt;</div><div class="line">        matReq(<span class="keyword">new</span> MatrixRequestData(matRequest-&gt;getRow(), matRequest-&gt;getCol(), MatrixType::MatrixC));</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;<a class="code" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">htgs::m_data_t&lt;double&gt;</a>&gt;(matReq, result, width, height, width));</div><div class="line"></div><div class="line">    this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba">releaseMemory</a>(matrixA);</div><div class="line">    this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba">releaseMemory</a>(matrixB);</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;HadamardProductTaskWithReleaseMem&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> HadamardProductTaskWithReleaseMem *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> HadamardProductTaskWithReleaseMem(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --> <h3><a class="anchor" id="tut2b-task-notes"></a>
Notes</h3>
<ul>
<li>Use the <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> function to get memory from a memory edge<ul>
<li><a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">htgs::TaskGraphConf::addMemoryManagerEdge</a> declares the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> responsible for getting memory</li>
<li>If an ITask calls <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> and that <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> was not designated having a memory edge, then the program will segmentation fault</li>
</ul>
</li>
<li>Releasing memory is done with the <a class="el" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba" title="Releases memory onto a memory edge, which is transferred by the graph communicator. ">htgs::ITask::releaseMemory</a> function<ul>
<li>Uses the htgs::m_data_t to provide meta data to return the memory to the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> that allocated the memory</li>
<li>The <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> is forwarded to the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> using the htgs::TaskGraphCommunicator<ul>
<li>Functionality with the htgs::TaskGraphCommunicator is mostly restricted to memory management</li>
</ul>
</li>
</ul>
</li>
<li>Even though it is a bottle-neck, the ReadDiskMatrixTask cannot significantly be sped up with multi-threading because it is limited by the speed of the computer's disk.</li>
</ul>
<h2><a class="anchor" id="tut2b-bookkeeper"></a>
Managing Dependencies with a Bookkeeper and IRules</h2>
<p>This tutorial reuses all of the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> and <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> implementations from <a class="el" href="tutorial2a.html#tut2a-bookkeeper">Tutorial2A</a></p>
<h2><a class="anchor" id="tut2b-memory-manager"></a>
Throttling Tasks with a Memory Manager</h2>
<p>The <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> is a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> that is created when adding a memory edge to a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>. A memory edge is similar to any other edge, except it connects directly to the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> rather than through a <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a>. This edge acts as a mechism for the task to get <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> from a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>. The <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> maintains a pool of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a>. Each <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> is inserted into the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>'s output <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a> This output <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a> is shared between the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> getting memory and the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>. If the <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a> has no data, then the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> will wait until the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> adds data along this edge.</p>
<p>a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> releases/recycles memory based on the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> that is attached to the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a>. The <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> is added to the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> using the <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> function. This is used to update the state of the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a>'s <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>, which determines when the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> can be readded into the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>'s memory pool. As soon as the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> is released/recycled, it is sent to the output <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a> for the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>. Returning <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> to its <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> is done by passing the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> that is received from the <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> function to the <a class="el" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba" title="Releases memory onto a memory edge, which is transferred by the graph communicator. ">htgs::ITask::releaseMemory</a> function. The <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> contain meta data that describes the name of the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> task and its address. This ensures the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> returns to the task that had allocated it.</p>
<p>Every memory edge contains a name associated with the edge. The name is used as an identifier for getting and releasing memory. As such, the names of the memory edges must be unique within a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<p>Any <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> can be specified as a task that is getting memory from a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> using the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">htgs::TaskGraphConf::addMemoryManagerEdge</a> function, which creates a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> and attaches it to the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>. The <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> that is specified must already exist within the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> prior to using the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">htgs::TaskGraphConf::addMemoryManagerEdge</a> Allocation, freeing, and the type of memory used within the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> is defined with a <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a>. The memory pool size is used to define the number of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> that is allocated within the memory pool. The <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a> and the memory pool size must take the data traversal behavior of the algorithm to ensure that there is enough memory data being sent from the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> and that there is not too much memory being allocated.</p>
<p>There are two types of MemoryManagers: Static and Dynamic. Each MemoryManager type modifies how/when memory is allocated and freed.</p>
<p>All MemoryManager types allocates a pool of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> during the <a class="el" href="classhtgs_1_1_i_task.html#af897c3050091c42e9afd364ac25c8eb6" title="Virtual function that is called when an ITask is being initialized by it&#39;s owner thread. ">htgs::ITask::initialize</a> phase. However, the Static MemoryManager will also allocate the memory associated with the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> using the <a class="el" href="classhtgs_1_1_i_memory_allocator.html#a49f280a9efff083ea4e198a91b10b93e" title="Pure virtual function that allocates a piece of memory with a specific size. ">htgs::IMemoryAllocator::memAlloc</a> function. The Static MemoryManager will release this memory once the destructor for the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> is called.</p>
<p>In the next sections, we will go into the details as to how each of these MemoryManager types vary and process MemoryData.</p>
<h3><a class="anchor" id="tut2b-static-mm"></a>
Static Memory Manager</h3>
<p>The static MemoryManager is a memory manager that recycles memory when it is released. All of the memory for the memory pool is allocated once when the MemoryManager is initialized and freed when the MemoryManager is shutdown. The diagram below shows how MemoryData is processed when an ITask releases memory. First, when MemoryData enters the MemoryManager, the MemoryData's state is updated using the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ad4d88cfa3383b6cc0e9e629e84d92e67" title="Pure virtual function to update the state of when memory has been used. ">htgs::IMemoryReleaseRule::memoryUsed</a> function.</p>
<p>Next, the MemoryManager checks the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ae6135cc2b517ea2bcf99617b312758dd" title="Pure virtual function to indicate when memory can be released. ">htgs::IMemoryReleaseRule::canReleaseMemory</a> function to determine whether the state indicates the memory can be freed or not. If the state indicates it can be freed, then the MemoryData is inserted into the MemoryPool. If it is not freed, then the MemoryData will not be recycled. Next, the MemoryPool is emptied into the MemoryManager's output Connector so the ITask getting memory can wake up and acquire MemoryData.</p>
<div class="image">
<img src="staticMemoryManager.png" alt="staticMemoryManager.png"/>
<div class="caption">
Static memory manager</div></div>
 <h3><a class="anchor" id="tut2b-dynamic-mm"></a>
Dynamic Memory Manager</h3>
<p>The dynamic MemoryManager contains a similar structure as the static MemoryManager with how it processes MemoryData. The primary difference is when the dynamic MemoryManager allocates and frees memory. In the static MemoryManager all memory is allocated during initialization and freed during shutdown. The dynamic MemoryManager allocates and frees memory on-the-fly. As shown in the diagram below, when MemoryData is sent from the releaseMemoryEdges, if the memory can be released, then the MemoryManager will free the memory that the MemoryData is managing. When the memoryEdges acquires memory from the MemoryManager, the ITask will allocate the memory that the MemoryData is managing prior to returning the MemoryData to the ITask. Using these mechanisms the memory is allocated and freed on demand.</p>
<div class="image">
<img src="dynamicMemoryManager.png" alt="dynamicMemoryManager.png"/>
<div class="caption">
Dynamic memory manager</div></div>
<p> Within the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> there are two functions that must be defined to use a MemoryManager edge: (1) <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a>, and (2) <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>. The Ihtgs::MemoryAllocator is specified when creating the memory edge, while the IMemoryReleaseRule is added to MemoryData when the memoryEdges gets memory. For the Hadamard product graph, we define the MatrixAllocator and MatrixMemoryRule as the <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a> and <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>, respectively. Below is the code that defines these classes.</p>
<p>The MatrixAllocator creates a one-dimensional array with the specified size using the new operator and releases the memory using the delete[] operator.</p>
<p>The MatrixMemoryRule uses a release count to determine when the memory is ready to be released. When the memoryGetter requests memory, a new instance of the MatrixMemoryRule is defined and bound to the MemoryData that is fetched. This IMemoryReleaseRule is then used by the MemoryManager by calling the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ad4d88cfa3383b6cc0e9e629e84d92e67" title="Pure virtual function to update the state of when memory has been used. ">htgs::IMemoryReleaseRule::memoryUsed()</a> function, which decrements the release count. The MemoryManager then checks if the memory can be released with the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ae6135cc2b517ea2bcf99617b312758dd" title="Pure virtual function to indicate when memory can be released. ">htgs::IMemoryReleaseRule::canReleaseMemory()</a>, which returns true if the release count is zero.</p>
<p>Each matrix block in the HadamardProduct is only used once, so after the specified row, column has been computed, then the memory associated with that computation can be released. This aspect is represented by defining the release count for the MatrixMemoryRule to be one.</p>
<h3><a class="anchor" id="tut2b-matrix-allocator"></a>
MatrixAllocator</h3>
<div class="fragment"><div class="line">#include &lt;htgs/api/IMemoryAllocator.hpp&gt;</div><div class="line"></div><div class="line">// MatrixAllocator&lt;Type&gt; to specify multiple types of memory; i.e. double or float </div><div class="line">template &lt;class Type&gt;</div><div class="line">class MatrixAllocator : public htgs::IMemoryAllocator&lt;Type&gt; {</div><div class="line"> public:</div><div class="line">  MatrixAllocator(size_t width, size_t height) : htgs::IMemoryAllocator&lt;Type&gt;(width * height) {}</div><div class="line"></div><div class="line">  Type *memAlloc(size_t size) {</div><div class="line">    Type *mem = new Type[size];</div><div class="line">    return mem;</div><div class="line">  }</div><div class="line"></div><div class="line">  Type *memAlloc() {</div><div class="line">    Type *mem = new Type[this-&gt;size()];</div><div class="line">    return mem;</div><div class="line">  }</div><div class="line"></div><div class="line">  void memFree(Type *&amp;memory) {</div><div class="line">    delete[] memory;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut2b-matrix-memory-rule"></a>
MatrixMemoryRule</h3>
<div class="fragment"><div class="line">#include &lt;htgs/api/IMemoryReleaseRule.hpp&gt;</div><div class="line"></div><div class="line"> class MatrixMemoryRule : public htgs::IMemoryReleaseRule {</div><div class="line">  public:</div><div class="line"></div><div class="line">   MatrixMemoryRule(size_t releaseCount) : releaseCount(releaseCount) {</div><div class="line">   }</div><div class="line"></div><div class="line">   void memoryUsed() {</div><div class="line">     releaseCount--;</div><div class="line">   }</div><div class="line"></div><div class="line">   bool canReleaseMemory() {</div><div class="line">     return releaseCount == 0;</div><div class="line">   }</div><div class="line"></div><div class="line">  private:</div><div class="line">   size_t releaseCount;</div><div class="line"> };</div></div><!-- fragment --><h3><a class="anchor" id="tut2b-memorymanagement-notes"></a>
Notes</h3>
<ul>
<li><a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> manages the memory that is used/recycled within a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> as well as to help throttle a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> to ensure the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> does not allocate too much memory.</li>
<li>There are two types of memory managers: Static and Dynamic<ul>
<li>Primary difference is how/when memory is allocated/freed</li>
</ul>
</li>
<li>When connecting a memory edge, the htgs:ITask that is getting memory must already be added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>The <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a> defines the type of memory that is allocated, how the memory is allocated, and how the memory is freed<ul>
<li>Use the type defined for the IMemoryAllocator&lt;Type&gt; when getting memory from within a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> using <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory&lt;Type&gt;()</a></li>
</ul>
</li>
<li>The <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> is used to define the state of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> to help determine when the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> can recycle/free memory<ul>
<li>The <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> is added to <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> when a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> gets memory using <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a>.</li>
<li>Each <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> should have a separate instance of the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> (a new instance per <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a>)</li>
</ul>
</li>
<li>The <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> should follow the data flow behavior of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> to ensure that the memory gets released.<ul>
<li>If memory does not get released and the memory getter is waiting for memory, then deadlock can occur.</li>
<li>There should be enough elements in the memory pool to progress the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> so that the IMemoryReleaseRule can allow data to be released.</li>
</ul>
</li>
<li>Use htgs::m_data_t&lt;Type&gt; as a shorthand for std::shared_ptr&lt;htgs::MemoryData&lt;Type&gt;&gt;<ul>
<li>std::shared_ptr&lt;htgs::MemoryData&lt;Type&gt;&gt; is returned from the <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a> function</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="tut2b-create-and-execute-taskgraph"></a>
Creating and Executing the TaskGraph</h2>
<p>Using the implementation from [tutorial 2a](tut2a-create-and-execute-taskgraph), we augment the graph using the HTGS API to specify the memory manager edges.</p>
<p>Belows is the source code implementation for setup, construction of the task TaskGraph, executing the TaskGraph, and processing the output of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<p>As before, the traversal order with operating on matrices A and B for the Hadamard product is defined using the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef" title="Produces data for the input of the TaskGraph. ">htgs::TaskGraphConf::produceData</a> function. If the structure presented below were to change the traversal to first iterate through requests for matrix A, followed by requests for matrix B in an entirely separate loop, then the requests for A would have to be fully processed prior to initiating the first computation on the Hadamard product. Using this traversal pattern would be detrimental to the memory management system as all of matrix A would have to be loaded prior to loading a single block of B, and if the system were to run out of memory prior to loading a block of B, then the graph would deadlock. Special care must be taken to how an algorithm initiates work into a graph that takes into account the behavior a traversal pattern has on memory and the computation.</p>
<p>The main function can be used to post-process data coming from the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>. If the data was allocated using a memory edge, then the main thread can use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a87ea35e80b6f26adaefed94f09598ef7" title="Releases memory back to its memory manager. ">htgs::TaskGraphConf::releaseMemory</a> function to return the memory to its <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>.</p>
<h3><a class="anchor" id="tut2b-main-function"></a>
Main function (Hadamard Product)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_conf_8hpp.html">htgs/api/TaskGraphConf.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_runtime_8hpp.html">htgs/api/TaskGraphRuntime.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixRequestData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/tasks/ReadDiskMatrixTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/allocator/MatrixAllocator.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../rules/HadamardLoadRule.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/HadamardProductTaskWithReleaseMem.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/SimpleClock.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/util-matrix.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/util-matrix.cpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/util-filesystem.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/util-filesystem.cpp&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line">  <span class="keywordtype">size_t</span> width = 1024;</div><div class="line">  <span class="keywordtype">size_t</span> height = 1024;</div><div class="line">  <span class="keywordtype">size_t</span> blockSize = 256;</div><div class="line">  <span class="keywordtype">size_t</span> numReadThreads = 1;</div><div class="line">  <span class="keywordtype">size_t</span> numProdThreads = 10;</div><div class="line">  std::string directory(<span class="stringliteral">&quot;data&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> arg = 1; arg &lt; argc; arg++) {</div><div class="line">    std::string argvs(argv[arg]);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--width&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      width = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--height&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      height = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--block-size&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      blockSize = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--num-readers&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      numReadThreads = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--num-workers&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      numProdThreads = (size_t)atoi(argv[arg]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--dir&quot;</span>) {</div><div class="line">      arg++;</div><div class="line">      directory = argv[arg];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (argvs == <span class="stringliteral">&quot;--help&quot;</span>) {</div><div class="line">      std::cout &lt;&lt; argv[0]</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; help: [--width &lt;#&gt;] [--height &lt;#&gt;] [--block-size &lt;#&gt;] [--num-readers &lt;#&gt;] [--num-workers &lt;#&gt;] [--dir &lt;dir&gt;] [--help]&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      exit(0);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Check directory for matrix files based on the given file size</span></div><div class="line">  checkAndValidateMatrixBlockFiles(directory, width, height, width, height, blockSize, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Use new tasks that contain functions for getting and releasing memory</span></div><div class="line">  ReadDiskMatrixTask *readMatTask = <span class="keyword">new</span> ReadDiskMatrixTask(numReadThreads, blockSize, width, height, directory, MatrixType::MatrixAny, <span class="keyword">false</span>);</div><div class="line">  HadamardProductTaskWithReleaseMem *prodTask = <span class="keyword">new</span> HadamardProductTaskWithReleaseMem(numProdThreads);</div><div class="line"></div><div class="line">  <span class="keywordtype">size_t</span> numBlocksCols = readMatTask-&gt;getNumBlocksCols();</div><div class="line">  <span class="keywordtype">size_t</span> numBlocksRows = readMatTask-&gt;getNumBlocksRows();</div><div class="line"></div><div class="line">  <span class="comment">// The data type that is passed now uses htgs::MemoryData</span></div><div class="line">  HadamardLoadRule&lt;htgs::m_data_t&lt;double&gt;&gt; *loadRule = <span class="keyword">new</span> HadamardLoadRule&lt;htgs::m_data_t&lt;double&gt;&gt;(numBlocksCols, numBlocksRows);</div><div class="line">  <span class="keyword">auto</span> bookkeeper = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&lt;htgs::m_data_t&lt;double&gt;</a>&gt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixRequestData, MatrixBlockData&lt;htgs::m_data_t&lt;double&gt;</a>&gt;&gt;();</div><div class="line"></div><div class="line">  taskGraph-&gt;setGraphConsumerTask(readMatTask);</div><div class="line">  taskGraph-&gt;addEdge(readMatTask, bookkeeper);</div><div class="line">  taskGraph-&gt;addRuleEdge(bookkeeper, loadRule, prodTask);</div><div class="line">  taskGraph-&gt;addGraphProducerTask(prodTask);</div><div class="line"></div><div class="line">  MatrixAllocator&lt;double&gt; *matAlloc = <span class="keyword">new</span> MatrixAllocator&lt;double&gt;(blockSize, blockSize);</div><div class="line"></div><div class="line">  <span class="comment">// Add memory edges</span></div><div class="line">  taskGraph-&gt;addMemoryManagerEdge(<span class="stringliteral">&quot;result&quot;</span>, prodTask, matAlloc, 50, htgs::MMType::Static);</div><div class="line">  taskGraph-&gt;addMemoryManagerEdge(<span class="stringliteral">&quot;MatrixA&quot;</span>, readMatTask, matAlloc, 100, htgs::MMType::Static);</div><div class="line">  taskGraph-&gt;addMemoryManagerEdge(<span class="stringliteral">&quot;MatrixB&quot;</span>, readMatTask, matAlloc, 100, htgs::MMType::Static);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a> *runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a>(taskGraph);</div><div class="line"></div><div class="line">  SimpleClock clk;</div><div class="line">  clk.start();</div><div class="line"></div><div class="line">  runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9">executeRuntime</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; numBlocksRows; row++) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; numBlocksCols; col++) {</div><div class="line">      MatrixRequestData *matrixA = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixA);</div><div class="line">      MatrixRequestData *matrixB = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixB);</div><div class="line"></div><div class="line">      taskGraph-&gt;produceData(matrixA);</div><div class="line">      taskGraph-&gt;produceData(matrixB);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  taskGraph-&gt;finishedProducingData();</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (!taskGraph-&gt;isOutputTerminated()) {</div><div class="line">    <span class="keyword">auto</span> data = taskGraph-&gt;consumeData();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (data != <span class="keyword">nullptr</span>) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Result received: &quot;</span> &lt;&lt; data-&gt;getRequest()-&gt;getRow() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; data-&gt;getRequest()-&gt;getCol()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="comment">// Release memory from the main thread</span></div><div class="line">      taskGraph-&gt;<a class="code" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba">releaseMemory</a>(data-&gt;getMatrixData());</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a8f2eaf040695178b6f61db7b0ee16c89">waitForRuntime</a>();</div><div class="line"></div><div class="line">  clk.stopAndIncrement();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">&quot;, height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="stringliteral">&quot;, blocksize: &quot;</span> &lt;&lt; blockSize &lt;&lt; <span class="stringliteral">&quot;, time: &quot;</span></div><div class="line">            &lt;&lt; clk.getAverageTime(TimeVal::MILLI) &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> runtime;</div><div class="line">}</div></div><!-- fragment --><p>Sample execution: </p><div class="fragment"><div class="line">./tutorial2-with-disk </div><div class="line">Result received: 1, 3</div><div class="line">Result received: 2, 1</div><div class="line">Result received: 2, 0</div><div class="line">Result received: 1, 2</div><div class="line">Result received: 0, 0</div><div class="line">Result received: 0, 1</div><div class="line">Result received: 0, 2</div><div class="line">Result received: 0, 3</div><div class="line">Result received: 1, 0</div><div class="line">Result received: 1, 1</div><div class="line">Result received: 3, 2</div><div class="line">Result received: 2, 3</div><div class="line">Result received: 2, 2</div><div class="line">Result received: 3, 0</div><div class="line">Result received: 3, 1</div><div class="line">Result received: 3, 3</div><div class="line">width: 1024, height: 1024, blocksize: 256, time: 5.78517 ms</div></div><!-- fragment --><h3><a class="anchor" id="tut2b-taskgraph-notes"></a>
Notes</h3>
<ul>
<li>For memory edges, the memory pool size parameter is import to specify based on amount of memory available and the dataflow behavior in relation to the memory usage behavior<ul>
<li>If not enough memory is available to allow for memory to be released, then the TaskGraph will deadlock</li>
<li>The more memory available, the more data elements that can flow through the TaskGraph to improve pipelining.</li>
</ul>
</li>
<li>Use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a87ea35e80b6f26adaefed94f09598ef7" title="Releases memory back to its memory manager. ">htgs::TaskGraphConf::releaseMemory</a> function to release any memory that is sent along the output of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
</ul>
<h1><a class="anchor" id="tut2b-summary"></a>
Summary </h1>
<p>In this tutorial, we looked at augmenting a graph to use disk and memory management.</p><ul>
<li>The various types of memory managers</li>
<li>How to use the memory management system with <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> and <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a></li>
<li>The importance of understanding memory usage behavior in relationship to memory edges to prevent TaskGraph deadlocks.</li>
<li>How the separation of concerns can be used to reuse existing code and add new functionality</li>
</ul>
<p>I encourage you to play around with parts A and B of the tutorials and see how performance is impacted using larger matrices, different block sizes, and various thread configurations. These can be quickly modified using the command-line parameters: --width, --height, --block-size, --num-readers, and --num-workers.</p>
<p>In the next tutorial, we will be implementing an in-core matrix multiplication using block decomposition and (optionally) the OpenBLAS API. The tutorial will introduce how to implement a slightly more complex dependency and the impacts of data traversal. We also show how to improve the utilization of a compute kernel by using an optimized variant. In addition, we will look into debugging and profiling using the <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a>.</p>
<p>To demonstrate these aspects, we have split Tutorial 3 into 3 parts.</p>
<ol type="1">
<li>Basic matrix multiplication</li>
<li>Identifying bottlenecks with profiling and debugging tools and ways to optimize with OpenBLAS</li>
<li>Computing with memory mapped files and identifying traversal patterns. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
