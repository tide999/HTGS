<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: Tutorial 3B</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial3b.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 3B </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut3b-objectives">Objectives </a></li>
<li class="level1"><a href="#tut3b-api-used">API Used </a><ul><li class="level2"><a href="#tut3b-imp-data-tasks-dep">Implementation, Data, Tasks, and Dependencies</a></li>
<li class="level2"><a href="#tut3b-debug-taskgraph">Debugging and Profiling htgs::TaskGraphConf</a><ul><li class="level3"><a href="#tut3b-vis-before">Visualizing Before Executing a htgs::TaskGraphConf</a></li>
<li class="level3"><a href="#tut3b-vis-after">Visualizing After Executing a htgs::TaskGraphConf</a></li>
</ul>
</li>
<li class="level2"><a href="#tut3b-optimize">Improving Utilization of Matrix Multiplication in HTGS</a><ul><li class="level3"><a href="#tut3b-taskgraph-notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#tut3b-summary">Summary </a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we revisit <a class="el" href="tutorial3a.html">Tutorial 3A</a> to investigate performance through the HTGS profiling/debugging visualization. One powerful component of HTGS is its high level abstractions that is explicitly represented throughout the analysis and implementation. These abstractions persist throughout execution, which can be used to profile and identify bottlenecks at a high level of abstraction.</p>
<h1><a class="anchor" id="tut3b-objectives"></a>
Objectives </h1>
<ol type="1">
<li>How to use the built-in dot generation tools that HTGS provides.<ul>
<li>Use GraphViz to convert dot file into image</li>
<li>Bit-flags to control visualization.</li>
</ul>
</li>
<li>How to profile an implementation with HTGS.</li>
<li>Methods to improve utilization within a task.</li>
</ol>
<h1><a class="anchor" id="tut3b-api-used"></a>
API Used </h1>
<ul>
<li>&lt;<a class="el" href="_task_graph_runtime_8hpp.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs/api/TaskGraphRuntime.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_conf_8hpp.html" title="Implements the task graph configuration class responsible for managing ITask connections. ">htgs/api/TaskGraphConf.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_task_8hpp.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs/api/ITask.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_dot_gen_flags_8hpp.html" title="Defines DOTGEN flags used for dot file generation. ">htgs/types/TaskGraphDotGenFlags.hpp</a>&gt;</li>
</ul>
<h2><a class="anchor" id="tut3b-imp-data-tasks-dep"></a>
Implementation, Data, Tasks, and Dependencies</h2>
<p>This tutorial uses the same implementation, data, tasks, and dependencies as presented in <a class="el" href="tutorial2a.html#tut2a-data">Tutorial 3A Data</a>.</p>
<h2><a class="anchor" id="tut3b-debug-taskgraph"></a>
Debugging and Profiling htgs::TaskGraphConf</h2>
<p>Building a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> will create an explicit represenatation of the task graph, which can be visualized using <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a>. This function can be called before or after launching the graph using the <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a>.</p>
<ol type="1">
<li>If called prior to calling <a class="el" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9" title="Executes the Runtime. ">htgs::TaskGraphRuntime::executeRuntime</a><ul>
<li>Will visualize the task graph configuration</li>
<li><a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a> will dynamically create new <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> and <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a><ul>
<li>Visualizing prior to execution provides a preview of the graph encapsulated within the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a></li>
</ul>
</li>
<li>Debugging</li>
</ul>
</li>
<li>If called after calling <a class="el" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9" title="Executes the Runtime. ">htgs::TaskGraphRuntime::executeRuntime</a><ul>
<li>Can be used to visualize profiling by specifying "-DPROFILE" during compilation</li>
<li>Can visualize during execution to identify errors/deadlocks<ul>
<li>A system to visualize the graph during execution via a web browser in quasi-realtime is in development</li>
</ul>
</li>
<li>Debugging and profiling</li>
</ul>
</li>
</ol>
<p>There are nine flags that are specified in the &lt;<a class="el" href="_task_graph_dot_gen_flags_8hpp.html" title="Defines DOTGEN flags used for dot file generation. ">htgs/types/TaskGraphDotGenFlags.hpp</a>&gt; header file, which can be used to configure the output of the visualization.</p>
<ol type="1">
<li>DOTGEN_FLAG_HIDE_MEM_EDGES<ul>
<li>Hides memory manager task and associated memory edge</li>
</ul>
</li>
<li>DOTGEN_FLAG_SHOW_ALL_THREADING<ul>
<li>Shows every task that is created (including those created for thread pools)</li>
<li>Only shows threads if called after execution</li>
</ul>
</li>
<li>DOTGEN_FLAG_SHOW_IN_OUT_TYPES<ul>
<li>Displays the input and output types for each task</li>
</ul>
</li>
<li>DOTGEN_FLAGS_HIDE_PROFILE_COMP_TIME<ul>
<li>Hides the compute time profiling data</li>
</ul>
</li>
<li>DOTGEN_FLAGS_HIDE_PROFILE_MAX_Q_SZ<ul>
<li>Hides the maximum queue size profiling data</li>
</ul>
</li>
<li>DOTGEN_FLAGS_HIDE_PROFILE_WAIT_TIME<ul>
<li>Hides the wait time profiling data</li>
</ul>
</li>
<li>DOTGEN_COLOR_COMP_TIME<ul>
<li>Colors the tasks based on compute time</li>
<li>Creates a separate file with the prefix: 'color-compute-time-"
  - Must specify "-DPROFILE" during compilation</li>
</ul>
</li>
<li>DOTGEN_COLOR_MAX_Q_SZ<ul>
<li>Colors the tasks based on the maximum queue size</li>
<li>Creates a separate file with the prefix: 'color-max-q-sz-"
  - Must specify "-DPROFILE" during compilation</li>
</ul>
</li>
<li>DOTGEN_COLOR_WAIT_TIME<ul>
<li>Colors the tasks based on the wait time</li>
<li>Creates a separate file with the prefix: 'color-wait-time-"
  - Must specify "-DPROFILE" during compilation</li>
</ul>
</li>
</ol>
<p>When profiling a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>, it is best to call <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a> after a call to <a class="el" href="classhtgs_1_1_task_graph_runtime.html#a8f2eaf040695178b6f61db7b0ee16c89" title="Waits for the Runtime to finish executing. ">htgs::TaskGraphRuntime::waitForRuntime</a>. This ensures that the graph has finished executing.</p>
<p>Below are examples of visualizing the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> from <a class="el" href="tutorial3a.html">Tutorial3A</a> before and after executing the graph.</p>
<h3><a class="anchor" id="tut3b-vis-before"></a>
Visualizing Before Executing a htgs::TaskGraphConf</h3>
<div class="fragment"><div class="line"><span class="comment">// Create tasks </span></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Build the task graph</span></div><div class="line">auto taskGraph = <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixRequestData, MatrixRequestData&gt;</a>();</div><div class="line">taskGraph-&gt;setGraphConsumerTask(distributeBk);</div><div class="line">taskGraph-&gt;addRuleEdge(distributeBk, distributeRuleMatA, readAMatTask);</div><div class="line">taskGraph-&gt;addRuleEdge(distributeBk, distributeRuleMatB, readBMatTask);</div><div class="line"></div><div class="line">taskGraph-&gt;addEdge(readAMatTask, matMulBk);</div><div class="line">taskGraph-&gt;addEdge(readBMatTask, matMulBk);</div><div class="line"></div><div class="line">taskGraph-&gt;addRuleEdge(matMulBk, loadRule, mmulTask);</div><div class="line"></div><div class="line">taskGraph-&gt;addEdge(mmulTask, matAccumBk);</div><div class="line">taskGraph-&gt;addRuleEdge(matAccumBk, accumulateRule, accumTask);</div><div class="line">taskGraph-&gt;addEdge(accumTask, matAccumBk);</div><div class="line"></div><div class="line">taskGraph-&gt;addRuleEdge(matAccumBk, outputRule, outputTask);</div><div class="line">taskGraph-&gt;addGraphProducerTask(outputTask);</div><div class="line"></div><div class="line"><span class="comment">// Write graph to file</span></div><div class="line">taskGraph-&gt;writeDotToFile(<span class="stringliteral">&quot;simple-graph.dot&quot;</span>);</div><div class="line">taskGraph-&gt;writeDotToFile(<span class="stringliteral">&quot;in-out-graph.dot&quot;</span>, <a class="code" href="_task_graph_dot_gen_flags_8hpp.html#a2e6ff8669b15dd1ebaefed15503207fc">DOTGEN_FLAG_SHOW_IN_OUT_TYPES</a>);</div><div class="line"></div><div class="line"><span class="comment">// Execute graph</span></div><div class="line">...</div></div><!-- fragment --><p>The graphs above were converted to a png (or pdf with -Tpdf) file using the following commands: </p><div class="fragment"><div class="line">dot -Tpng -o simple-graph.png simple-graph.dot</div><div class="line">dot -Tpng -o in-out-graph.png in-out-graph.dot</div></div><!-- fragment --><p><a href="simple-graph.png">simple-graph.png</a></p>
<p><a href="in-out-graph.png">in-out-graph.png</a></p>
<p>In the figures above, each graph shows the explicit representation that is to be used to process matrix multiplication. Tasks have the "x&lt;#&gt;" notation, where &lt;#&gt; represents the number of tasks copied and bound to separate threads. These threads have not been spawned yet, but provide an indicator as to how many threads will be spawned to execute each task within the graph. Every <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> have annotated output edges that provide the name of the rule that is responsible for processing that edge.</p>
<p>In addition there are nodes between tasks that represent the <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>, which manages the thread-safe queue for the task. The number within this node represents the number of active connections that will be producing data for the connector. During execution, if this number reaches zero, then that edge is considered no longer receiving data (terminated), which can be checked with <a class="el" href="classhtgs_1_1_connector.html#ac57f6cb1a8f74822d3e11d8277d3e696" title="Checks whether the producer for this Connector has finished pushing data onto its queue...">htgs::Connector::isInputTerminated</a>. At the top and bottom of the visualization are the "Graph Input" and "Graph Output" nodes, which represent the input and output connectors for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<p>In the in-out-graph.png figure, every task have additional details showing the specific input and output data types for each task.</p>
<p>These figures can be used to ensure the graph representation that is done during analysis maps well into the actual implementation.</p>
<h3><a class="anchor" id="tut3b-vis-after"></a>
Visualizing After Executing a htgs::TaskGraphConf</h3>
<p>During compilation we include "-DPROFILE" to enable profiling of the graph.</p>
<div class="fragment"><div class="line"><span class="comment">// Create tasks </span></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Build the task graph</span></div><div class="line">auto taskGraph = <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixRequestData, MatrixRequestData&gt;</a>();</div><div class="line">taskGraph-&gt;setGraphConsumerTask(distributeBk);</div><div class="line">taskGraph-&gt;addRuleEdge(distributeBk, distributeRuleMatA, readAMatTask);</div><div class="line">taskGraph-&gt;addRuleEdge(distributeBk, distributeRuleMatB, readBMatTask);</div><div class="line"></div><div class="line">taskGraph-&gt;addEdge(readAMatTask, matMulBk);</div><div class="line">taskGraph-&gt;addEdge(readBMatTask, matMulBk);</div><div class="line"></div><div class="line">taskGraph-&gt;addRuleEdge(matMulBk, loadRule, mmulTask);</div><div class="line"></div><div class="line">taskGraph-&gt;addEdge(mmulTask, matAccumBk);</div><div class="line">taskGraph-&gt;addRuleEdge(matAccumBk, accumulateRule, accumTask);</div><div class="line">taskGraph-&gt;addEdge(accumTask, matAccumBk);</div><div class="line"></div><div class="line">taskGraph-&gt;addRuleEdge(matAccumBk, outputRule, outputTask);</div><div class="line">taskGraph-&gt;addGraphProducerTask(outputTask);</div><div class="line"></div><div class="line"><span class="comment">// Execute graph</span></div><div class="line"><span class="keyword">auto</span> runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a>(taskGraph);</div><div class="line"></div><div class="line"><span class="comment">// Produce data</span></div><div class="line">...</div><div class="line"></div><div class="line">taskGraph-&gt;finishedProducingData();</div><div class="line"></div><div class="line">taskGraph-&gt;waitForRuntime();</div><div class="line"></div><div class="line">taskGraph-&gt;writeDotToFile(<span class="stringliteral">&quot;profile-graph.dot&quot;</span>);</div><div class="line">taskGraph-&gt;writeDotToFile(<span class="stringliteral">&quot;profile-all-threads-graph.dot&quot;</span>, <a class="code" href="_task_graph_dot_gen_flags_8hpp.html#ad40fb64b87d99f44df0b2bf8f639fa22">DOTGEN_FLAG_SHOW_ALL_THREADING</a>);</div><div class="line">taskGraph-&gt;writeDotToFile(<span class="stringliteral">&quot;profile-graph.dot&quot;</span>, <a class="code" href="_task_graph_dot_gen_flags_8hpp.html#addb6f01190e590724da3d916f850473a">DOTGEN_COLOR_COMP_TIME</a> | <a class="code" href="_task_graph_dot_gen_flags_8hpp.html#ad54a5b39c58c019c8819d7e90b6b5225">DOTGEN_COLOR_MAX_Q_SZ</a> | <a class="code" href="_task_graph_dot_gen_flags_8hpp.html#a569de2fe02f1cc5f096554d171efe77b">DOTGEN_COLOR_WAIT_TIME</a>);</div></div><!-- fragment --><p>We execute this version using the following command (includes associated output): </p><div class="fragment"><div class="line">./tutorial3 --block-size 256 --width-b 2048 --height-a 2048 --shared-dim 2048 --num-workers 20</div><div class="line">Writing dot file for task graph to profile-graph.dot</div><div class="line">Writing dot file for task graph to profile-all-threads-graph.dot</div><div class="line">Writing dot file for task graph with compute time coloring to color-compute-time-profile-graph.dot</div><div class="line">Writing dot file for task graph with wait time coloring to color-wait-time-profile-graph.dot</div><div class="line">Writing dot file for task graph with max Q size coloring to color-max-q-sz-profile-graph.dot</div><div class="line">htgs, 20, accum-threads: 10, width-b: 2048, height-a: 2048, shared-dim: 2048, blockSize: 256, time:1291.56, end-to-end:1291.83</div></div><!-- fragment --><p>The code above will generate five visualizations. (with adding -DPROFILE to compilation)</p><ol type="1">
<li>profile-graph.dot<ul>
<li>Generates profiling data for each task.</li>
<li>Thread pool timings are averaged for each task</li>
</ul>
</li>
<li>profile-all-threads.dot<ul>
<li>Generates the profiling for each task with threads fully expanded</li>
</ul>
</li>
<li>color-compute-time-profile-graph.dot<ul>
<li>Generates profiling data for each task, where tasks are colored based on compute time</li>
</ul>
</li>
<li>color-wait-time-profile-graph.dot<ul>
<li>Generates profiling data for each task, where tasks are colored based on wait time</li>
</ul>
</li>
<li>color-max-q-sz-profile-graph.dot<ul>
<li>Generates profiling data for each task, where tasks are colored based on the maximum queue size</li>
</ul>
</li>
</ol>
<p>As shown in the source code above, each DOTGEN flag can be aggregated using the bit-wise OR operator.</p>
<p>Below are the resulting figures for each graph after using the following commands: </p><div class="fragment"><div class="line">dot -Tpng -o profile-graph.png profile-graph.dot</div><div class="line">dot -Tpng -o profile-all-threads.png profile-all-threads.dot</div><div class="line">dot -Tpng -o color-compute-time-profile-graph.png color-compute-time-profile-graph.dot</div><div class="line">dot -Tpng -o color-wait-time-profile-graph.png color-wait-time-profile-graph.dot</div><div class="line">dot -Tpng -o color-max-q-sz-profile-graph.png color-max-q-sz-profile-graph.dot</div></div><!-- fragment --><p><a href="profile-graph.png">profile-graph.png</a></p>
<p><a href="profile-all-threads-graph.png">profile-all-threads-graph.png</a></p>
<p><a href="color-compute-time-profile-graph.png">color-compute-time-profile-graph.png</a></p>
<p><a href="color-wait-time-profile-graph.png">color-wait-time-profile-graph.png</a></p>
<p><a href="color-max-q-sz-profile-graph.png">color-max-q-sz-profile-graph.png</a></p>
<p>profile-graph.png shows the compute time, wait time, and max queue size for each task. Any task that has multiple threads associated are reporting the average timings for that task.</p>
<p>profile-all-threads-graph.png shows the fully expanded graph and all threading.</p>
<p>These graphs are useful to get a glimpse at the overall timings for each task. Using the coloring options provides a much clearer picture to pinpoint the bottleneck(s) within an implementation. First, the color-compute-time-profile-graph.png creates a color map based around the compute times. The cooler blue times are less impactful, whereas the hot red times have high impact. The MatMulBlkTask is colored bright red, which indicates this task is the main bottleneck. The color-wait-time and color-max-q-sz graphs support this observation. In addition, the color-wait-time and color-max-q-sz are showing that the MatMulAccumTask and MatMulOutPutTaskWithDisk tasks are spending the majority of their time waiting for data. Improving the execution time of the MatMulBlkTask should reduce reduce the wait time for these tasks; however, in some cases modifying traversal patterns for inserting data into the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> from the main thread or optimizing data locality can provide additional benefits.</p>
<p>To improve the performance of this implementation, we investigate methods for improving the MatMulBlkTask.</p>
<h2><a class="anchor" id="tut3b-optimize"></a>
Improving Utilization of Matrix Multiplication in HTGS</h2>
<p>The MatMulBlkTask can be thought of as an in-core computational kernel that executes on the CPU. Methods for fine-grained parallelism, such as utilizing L1 cache and instruction-level parallelism can be used to improve the overall CPU utilization for this task. Alternatively, an accelerator could be incorporated into the graph to offload the computation to high bandwidth massively parallel hardware (shown in Tutorial4A).</p>
<p>The current implementation of matrix multiplication uses a triple nested for loop that iterates across the entire matrix, shown <a href="https://github.com/usnistgov/HTGS-Tutorials/blob/master/tutorial-utils/matrix-library/operations/matmul.cpp">here</a>. Instead of taking the time to optimize this code, existing in-core compute kernels are available, such as those from <a href="http://www.openblas.net/">OpenBLAS</a>. OpenBLAS implements various basic linear algebra operators and will generate a per-architecture optimized library. Using this library should boost the performance for our MatMulBlkTask.</p>
<p>Before incorporating OpenBLAS into the MatMulBlkTask, one additional component can be taken into account to quantify this improvement.</p>
<p>Each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> contain two additional functions that will add customizable details to the visualization. This can be applied before or after execution of an <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<p>Implementing the <a class="el" href="classhtgs_1_1_any_i_task.html#a6c9ea546ef2f5ef08d7e579d34d0dc46" title="Provides debug output for a node in the dot graph. ">htgs::ITask::debugDotNode</a> is intended to add debug output. The <a class="el" href="classhtgs_1_1_i_task.html#a20ee37165592d050252488a32fdaf595" title="Adds the string text to the profiling of this task in the graphviz dot visualization. ">htgs::ITask::getDotCustomProfile</a> can be used to provide additional custom profiling data that will be added to the dot visualization. This can be used in conjunction with htgs::ITask::getComputeTime, to obtain the compute time of the htgs:ITask in microseconds.</p>
<p>Below, we incorporate a GFLops benchmark into the MatMulBlkTask. This allows us to track the performance within this task.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/operations/matmul.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../../tutorial-utils/matrix-library/data/MatrixBlockMulData.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MatMulBlkTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixBlockMulData&lt;double *&gt;, MatrixBlockData&lt;double *&gt;&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatMulBlkTask(<span class="keywordtype">size_t</span> numThreads, <span class="keywordtype">bool</span> colMajor) :</div><div class="line">      ITask(numThreads), colMajor(colMajor), numOps(0) {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixBlockMulData&lt;double *&gt;&gt; data) {</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matAData = data-&gt;getMatrixA();</div><div class="line">    <span class="keyword">auto</span> matBData = data-&gt;getMatrixB();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *matrixA = matAData-&gt;getMatrixData();</div><div class="line">    <span class="keywordtype">double</span> *matrixB = matBData-&gt;getMatrixData();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> width = matBData-&gt;getMatrixWidth();</div><div class="line">    <span class="keywordtype">size_t</span> height = matAData-&gt;getMatrixHeight();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> lda = matAData-&gt;getLeadingDimension();</div><div class="line">    <span class="keywordtype">size_t</span> ldb = matBData-&gt;getLeadingDimension();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> ldc;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (colMajor)</div><div class="line">      ldc = height;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      ldc = width;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *result = <span class="keyword">new</span> <span class="keywordtype">double</span>[width * height];</div><div class="line"></div><div class="line">    computeMatMul(height, width, matAData-&gt;getMatrixWidth(), 1.0, matrixA, lda,</div><div class="line">                  matrixB, ldb, 0.0, result, ldc, colMajor);</div><div class="line"></div><div class="line">    <span class="comment">// Compute total number of operations being done by this task</span></div><div class="line">    numOps += height * width * matAData-&gt;getMatrixWidth();</div><div class="line"></div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt; matReq(<span class="keyword">new</span> MatrixRequestData(matAData-&gt;getRequest()-&gt;getRow(),</div><div class="line">                                                                    matBData-&gt;getRequest()-&gt;getCol(),</div><div class="line">                                                                    MatrixType::MatrixC));</div><div class="line"></div><div class="line">    this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;double *&gt;(matReq, result, width, height, ldc));</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatMulBlkTask&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> MatMulBlkTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> MatMulBlkTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a4f074ff0b07c5d1106351f4200dc6b1e">getNumThreads</a>(), colMajor);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Output gflops performance</span></div><div class="line">  std::string <a class="code" href="classhtgs_1_1_i_task.html#a20ee37165592d050252488a32fdaf595">getDotCustomProfile</a>()<span class="keyword"> override </span>{</div><div class="line">    <span class="keyword">auto</span> microTime = this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#a0c1de80af7618361183edc300b39b5cf">getTaskComputeTime</a>();</div><div class="line">    <span class="keywordtype">double</span> numGFlop = ((double)numOps * 2.0) * 1.0e-9d;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> timeSec = (double)microTime / 1000000.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Performance: &quot;</span> + std::to_string(numGFlop / timeSec) + <span class="stringliteral">&quot; gflops&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">bool</span> colMajor;</div><div class="line">  <span class="keywordtype">size_t</span> numOps;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Using the above implementation of the task outputs the number of gflops performed by a task.</p>
<p>Using this variant, we execute with the following command and output the task graph dot file.</p>
<div class="fragment"><div class="line">./tutorial3 --block-size 128 --width-b 2048 --height-a 2048 --shared-dim 2048 --num-workers 20</div><div class="line">Writing dot file for task graph to profile-all-threads-graph.dot</div><div class="line">Writing dot file for task graph with compute time coloring to color-compute-time-profile-graph.dot</div><div class="line">htgs, 20, accum-threads: 10, width-b: 2048, height-a: 2048, shared-dim: 2048, blockSize: 128, time:1268.35, end-to-end:1268.84</div></div><!-- fragment --><p>This implementation achieves 13.5 GFlops. Viewing the graph visualization, we see the first thread for the MatMulBlkTask is achieving 0.7 GFlops. With 20 threads this is approximately 14 GFlops, note that this is not taking into account the final accumulation step. To view the actual GFlop rating for each MatMulBlkTask thread, we can use the DOTGEN_FLAG_SHOW_ALL_THREADING flag, also shown below.</p>
<p><a href="color-compute-time-profile-gflops-graph.png">Profile with GFlops</a></p>
<p><a href="profile-all-threads-gflops-graph.png">Profile with all threads and GFlops</a></p>
<p>Now that we have a clear metric to base our task performance off of, we incorporate OpenBLAS into the computation.</p>
<p>Example call for OpenBLAS, also found <a href="https://github.com/usnistgov/HTGS-Tutorials/blob/master/tutorial-utils/matrix-library/operations/matmul.cpp">here</a>: </p><div class="fragment"><div class="line">cblas_dgemm(ColMajor ? CblasColMajor : CblasRowMajor, CblasNoTrans, CblasNoTrans, M, N, K, alpha, A, LDA, B, LDB, beta, C, LDC);</div></div><!-- fragment --><p>To enable using OpenBLAS in the HTGS-Tutorials, define the following during cmake (or cmake-gui/ccmake)</p>
<ol type="1">
<li>-DLIBOPENBLAS_INCLUDE_DIR={PATH_TO_OPENBLAS INCLUDE DIR}</li>
<li>-DLIBOPENBLAS_LIBRARY={PATH_TO_OPENBLAS LIB DIR}</li>
</ol>
<p>Defining these options will enable using OpenBLAS for Tutorial 3. We execute the same command as above with OpenBLAS enabled.</p>
<div class="fragment"><div class="line">./tutorial3 --block-size 128 --width-b 2048 --height-a 2048 --shared-dim 2048 --num-workers 20</div><div class="line">Writing dot file for task graph to profile-all-threads-graph.dot</div><div class="line">Writing dot file for task graph with compute time coloring to color-compute-time-profile-graph.dot</div><div class="line">htgs, 20, accum-threads: 10, width-b: 2048, height-a: 2048, shared-dim: 2048, blockSize: 128, time:116.368, end-to-end:116.83</div></div><!-- fragment --><p>With OpenBLAS enabled, the implementation now achieves 148.1 GFlops. The graph visualization now shows the first thread achieves 5.92 Gflops, which is approximately, 118.4 GFlops. Viewing all of the threads shows a clearer picture about utilization, where some threads achieved up to 12.79 GFlops.</p>
<p><a href="color-compute-time-profile-gflops-openblas-graph.png">Profile with OpenBLAS</a></p>
<p><a href="profile-all-threads-gflops-openblas-graph.png">Profile with all threads OpenBLAS</a></p>
<p>Overall, this shows an overall speedup of 10x for this small problem size.</p>
<p>Now that the MatMulBlk task has been improved, we can experiment further to analyze the impact of block-size. I leave this task up to you to see how far you can push the GFlops performance for the MatMulBlk task by altering the matrix dimensions and block sizes.</p>
<h3><a class="anchor" id="tut3b-taskgraph-notes"></a>
Notes</h3>
<ul>
<li>Using the <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a> can provide extremely useful profiling data the maps directly into the analysis<ul>
<li>Can be used for profiling and debugging</li>
<li>Using DOTGEN flags from &lt;<a class="el" href="_task_graph_dot_gen_flags_8hpp.html" title="Defines DOTGEN flags used for dot file generation. ">htgs/types/TaskGraphDotGenFlags.hpp</a>&gt; can customize the output</li>
<li>Enable debugging by compiling with -DPROFILE</li>
</ul>
</li>
<li>Adding custom profile output with <a class="el" href="classhtgs_1_1_i_task.html#a20ee37165592d050252488a32fdaf595" title="Adds the string text to the profiling of this task in the graphviz dot visualization. ">htgs::ITask::getDotCustomProfile</a> can be used to view per-task utilization<ul>
<li>Added to comptuational task can show GFlops</li>
<li>Could also be used to profile bandwidth</li>
</ul>
</li>
<li>Benefits available to per-task optimizations that take better advantage of the underlying architecture</li>
</ul>
<h1><a class="anchor" id="tut3b-summary"></a>
Summary </h1>
<p>In this tutorial, we revisited the matrix multiplication implementation from <a class="el" href="tutorial3a.html">Tutorial3A</a>.</p><ol type="1">
<li>Methods for visually debugging and profiling the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>Approaches for customizing the visualization to include additional attributes<ul>
<li>Can be used to show GFlops per task or other metrics (i.e. bandwidth)</li>
</ul>
</li>
<li>Strategies to optimize<ul>
<li>Take advantage of BLAS libraries to utilize optimized compute kernels</li>
</ul>
</li>
</ol>
<p>Working at a higher level abstractions within HTGS enables analyzing the algorithm at that abstraction, which can be used to identify bottlenecks and make decisions on a per-task basis. More advanced techniques, such as changing data representations and traversal patterns can also be used to improve utilization and data reuse.</p>
<p>An implementation that adds memory mapped files and the disk are also available in the HTGS-Tutorials code-base. Memory mapped files will only work on Linux and OSX systems. Next, Tutorial4 will revisit matrix multiplication and incorporate NVIDIA GPUs into the computation. If you do not have an NVIDIA GPU, then skip to Tutorial6. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
