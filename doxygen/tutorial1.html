<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTGS: Tutorial 1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial1.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut1-objectives">Objectives </a></li>
<li class="level1"><a href="#tut1-api-used">API Used </a></li>
<li class="level1"><a href="#tut1-implementation">Implementation </a><ul><li class="level2"><a href="#tut1-data">Data</a><ul><li class="level3"><a href="#tut1-input-data">Input data implementation</a></li>
<li class="level3"><a href="#tut1-output-data">Output data implementation</a></li>
<li class="level3"><a href="#tut1-data-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut1-tasks">Tasks</a><ul><li class="level3"><a href="#tut1-addtask-implementation">AddTask Implementation</a></li>
<li class="level3"><a href="#tut1-task-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tut1-create-and-execute-taskgraph">Creating and Executing the htgs::TaskGraphConf</a><ul><li class="level3"><a href="#tut1-main-function">Main function (create and execute TaskGraph)</a></li>
<li class="level3"><a href="#tut1-debug">Debugging and profiling a htgs::TaskGraphConf</a></li>
<li class="level3"><a href="#taskgraph-notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#summary">Summary </a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we will be introducing the basics of the Hybrid Task Graph Scheduler (HTGS) API.</p>
<p>The <a href="https://github.com/usnistgov/HTGS-Tutorials/tree/master/tutorial1">Source Code</a> can be viewed in the HTGS-Tutorials github repository.</p>
<p>We will be implementing a simple add function to add two numbers and return the result, which introduces the API and how to work with it.</p>
<h1><a class="anchor" id="tut1-objectives"></a>
Objectives </h1>
<ol type="1">
<li>How to represent data: (input and output)<ul>
<li>How to customize the priority of data (optional)</li>
</ul>
</li>
<li>How to operate on data with an ITask</li>
<li>How to add an ITask to a TaskGraph</li>
<li>How to add data into a TaskGraph</li>
<li>How to process data from a TaskGraph</li>
</ol>
<h1><a class="anchor" id="tut1-api-used"></a>
API Used </h1>
<ul>
<li>&lt;<a class="el" href="_i_data_8hpp.html" title="Implements the IData class, which is used for all data types entering/leaving a task graph...">htgs/api/IData.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_task_8hpp.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs/api/ITask.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_conf_8hpp.html" title="Implements the task graph configuration class responsible for managing ITask connections. ">htgs/api/TaskGraphConf.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_runtime_8hpp.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs/api/TaskGraphRuntime.hpp</a>&gt;</li>
</ul>
<h1><a class="anchor" id="tut1-implementation"></a>
Implementation </h1>
<p>Below we will go into detail on each of the components needed to implement the algorithm x+y=z. Before we implement any code, we must analyze the algorithm and transform it into a dataflow graph. The dataflow graph provides a high level view of the algorithm such as data dependencies, control flow, and compute instances.</p>
<p>Algorithm: <img class="formulaInl" alt="$x+y=z$" src="form_0.png"/></p>
<p>Dataflow graph:</p>
<div class="image">
<img src="tut1XY-dataflow.png" alt="tut1XY-dataflow.png"/>
<div class="caption">
XY Dataflow</div></div>
<p> TaskGraph:</p>
<div class="image">
<img src="tut1XY-taskgraph.png" alt="tut1XY-taskgraph.png"/>
<div class="caption">
XY Taskgraph</div></div>
<p> We transform the dataflow graph into a TaskGraph. We have two input types for the x+y operation, so we will compose the inputs into a single object to hold both x and y data. The result of the graph is a single value, so another data object is used to hold the ouput. There will be one compute task, which is responsible for the operation x+y and producing the result z.</p>
<h2><a class="anchor" id="tut1-data"></a>
Data</h2>
<p>The algorithm we are implementing adds two numbers and returns a result. One <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> class will be responsible for passing the two numbers to a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> and another <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> class will store the output. <b><a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> is defined by inheriting the <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> interface.</b></p>
<p>When data is passed from <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> to <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> (or as input/output of a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>) it is inserted into a <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>, which uses a FIFO queue to hold data (transformed into a priority queue using the USE_PRIORITY_QUEUE directive)</p>
<p>If a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> expects multiple input values, then <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> can act as a container where each of those input values are stored within a single object.</p>
<p>All data in HTGS is represented as <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a>. <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> is an interface and contains only one (optional) virtual function: <a class="el" href="classhtgs_1_1_i_data.html#a28954e06d09f04d288779267cd276c5a" title="Virtual IData comparison function, can be used for custom ordering. ">htgs::IData::compare</a>. The compare function can be used to customize the ordering of data in the <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>'s queue. <b>Priority is enabled only if the USE_PRIORITY_QUEUE directive is defined.</b></p>
<h3><a class="anchor" id="tut1-input-data"></a>
Input data implementation</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div><div class="line"><span class="comment">// with &#39;: public htgs::IData&#39;, InputData becomes a child of IData and can be used within htgs::ITask&#39;s</span></div><div class="line"><span class="keyword">class </span>InputData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a></div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  InputData(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) : x(x), y(y) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> getX()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x; }</div><div class="line">  <span class="keywordtype">int</span> getY()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> y; }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> x;</div><div class="line">  <span class="keywordtype">int</span> y;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut1-output-data"></a>
Output data implementation</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>OutputData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Optional IData(size_t order) constructor to specify ordering of OutputData (must define USE_PRIORITY_QUEUE directive)</span></div><div class="line">  OutputData(<span class="keywordtype">int</span> result) : IData(result),  result(result) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> getResult()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> result; }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> result;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut1-data-notes"></a>
Notes</h3>
<ul>
<li><a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> can hold any number of input parameters being sent to a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>Assuming USE_PRIORITY_QUEUE directive is defined<ul>
<li>Uses order constructor for <a class="el" href="classhtgs_1_1_i_data.html#a85c04d1470d11fe8aa8bf8c5dceadf94" title="Constructs IData with integer ordering. ">htgs::IData::IData(size_t order)</a>, which will provide an ordering based on the lowest value first.</li>
<li>The ordering can be customized if the <a class="el" href="classhtgs_1_1_i_data.html#a28954e06d09f04d288779267cd276c5a" title="Virtual IData comparison function, can be used for custom ordering. ">htgs::IData::compare</a> function is overriden</li>
<li>Defined by specifying -DUSE_PRIORITY_QUEUE during compilation.<ul>
<li>In CMake, add_definitions(-DUSE_PRIORITY_QUEUE)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Example altering the order of data to highest value first (USE_PRIORITY_QUEUE directive to enable priority): </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> compare(<span class="keyword">const</span> std::shared_ptr&lt;OutputData&gt; p2)<span class="keyword"> const </span>{</div><div class="line">    <span class="comment">// getOrder() is inherited from the htgs::IData class</span></div><div class="line">    <span class="keywordflow">return</span> this-&gt;getOrder() &lt; p2-&gt;getOrder();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="tut1-tasks"></a>
Tasks</h2>
<p>To implement the add function of the algorithm, we will only be needing one <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>. <b>A task is defined by inheriting <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>.</b></p>
<p>The <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> specifies five virtual functions that customize the functionality of a task:</p><ol type="1">
<li><a class="el" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d" title="Pure virtual function that is called when an ITask&#39;s thread is to execute on data. ">htgs::ITask::executeTask</a> - Consumes one input <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> object and produces zero or more output <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> objects. Data is produced as output for the task by calling the <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa" title="Adds results to the output list to be sent to the next connected ITask in a TaskGraph. ">htgs::ITask::addResult</a> function.</li>
<li><a class="el" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6" title="Pure virtual function to copy an ITask. ">htgs::ITask::copy</a> - Creates a copy of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>, each copy is bound to a separate thread to form a thread pool for the task</li>
<li><a class="el" href="classhtgs_1_1_i_task.html#af897c3050091c42e9afd364ac25c8eb6" title="Virtual function that is called when an ITask is being initialized by it&#39;s owner thread. ">htgs::ITask::initialize</a> - (Optional) Called when a CPU thread has attached to the task. This can be used to allocate local task-level memory and/or bind the task and thread to an accelerator. DEFAULT: Does nothing.</li>
<li><a class="el" href="classhtgs_1_1_i_task.html#a8ea8be928ea7e5a1c7dab9dd889cb268" title="Virtual function that is called when an ITask is checking if it can be terminated. ">htgs::ITask::canTerminate</a> - (Optional) Identifies if the task is ready to terminate. DEFAULT: Terminates when there is no longer any input coming from the task using <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>:isInputTerminated</li>
<li><a class="el" href="classhtgs_1_1_i_task.html#acad9dd61bff4a2d2f96bbb4532a3bb82" title="Virtual function that is called when an ITask is being shutdown by it&#39;s owner thread. ">htgs::ITask::shutdown</a> - (Optional) Called when the task is terminating. DEFAULT: Does nothing.</li>
</ol>
<p>Every <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> has an input type and and output type. These types are defined by the first and second template parameters, respectively.</p>
<p>The number of threads that are associated with a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> and how it interacts with the thread are controlled using one of the four <a class="el" href="classhtgs_1_1_i_task.html#ac23fa74bf05d6a86000422d989ccc5d1" title="Creates an ITask with number of threads equal to 1. ">htgs::ITask::ITask</a> constructors. For example using <a class="el" href="classhtgs_1_1_i_task.html#a02582007e35e26b6487296102491ab8a" title="Constructs an ITask with a specified number of threads. ">htgs::ITask::ITask(size_t numThreads)</a> will allocate numThreads threads for this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>. By doing so, increases the number of threads consuming input data. The <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> also has additional capabilities that can be used in conjunction with the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a>, such as getting the pipelineId. These advanced features will be described in a later tutorial.</p>
<p>A <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a> is created when adding a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> to a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>. The <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a> interacts with the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> by sending the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> data and producing data when the <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa" title="Adds results to the output list to be sent to the next connected ITask in a TaskGraph. ">htgs::ITask::addResult</a> is called. The <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a> can be controlled through some of the more advanced constructors from the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>. Below is a brief description of what these parameters do.</p><ol type="1">
<li>numThreads - How many threads are spawned for the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> (&gt;=1)</li>
<li>isStartTask - If set to TRUE, then immediately processes one data item, sent as nullptr, to the htgs::ITask::executTask function. Can be used to begin processing producing data from a task, such as reading from disk.</li>
<li>poll - If set to TRUE, will continually poll for data from the input connector based on a timeout period. If the timeout expires, then nullptr data is sent to the htgs::ITask::executTask function</li>
<li>microTimeoutTime - The timeout time in microseconds for polling.</li>
</ol>
<p>The interaction between the ITask, <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a>, and <a class="el" href="classhtgs_1_1_task_manager_thread.html" title="Manages a TaskManager that is bound to a thread for execution. ">htgs::TaskManagerThread</a> is shown below:</p>
<div class="image">
<img src="tut1-itask-callgraph.png" alt="tut1-itask-callgraph.png"/>
</div>
<h3><a class="anchor" id="tut1-addtask-implementation"></a>
AddTask Implementation</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../data/InputData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/OutputData.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// with &#39;:public htgs::ITask&lt;InputData, OutputData&gt;&#39;, AddTask becomes a child of ITask, </span></div><div class="line"><span class="comment">// which consumes data of type InputData and produces data of type OutputData</span></div><div class="line"><span class="keyword">class </span>AddTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;InputData, OutputData&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;InputData&gt; data)<span class="keyword"> override </span>{</div><div class="line">        <span class="comment">// Adds x + y</span></div><div class="line">        <span class="keywordtype">int</span> sum = data-&gt;getX() + data-&gt;getY();</div><div class="line"></div><div class="line">        <span class="comment">// Sends data along output edge</span></div><div class="line">        this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> OutputData(sum));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> AddTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>()<span class="keyword"> override </span>{</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> AddTask();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Optional</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#af897c3050091c42e9afd364ac25c8eb6">initialize</a>()<span class="keyword"> override </span>{ }</div><div class="line"></div><div class="line">    <span class="comment">// Optional</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#acad9dd61bff4a2d2f96bbb4532a3bb82">shutdown</a>()<span class="keyword"> override </span>{ }</div><div class="line"></div><div class="line">    <span class="comment">// Optional</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhtgs_1_1_i_task.html#a8ea8be928ea7e5a1c7dab9dd889cb268">canTerminate</a>(std::shared_ptr&lt;htgs::AnyConnector&gt; inputConnector)<span class="keyword"> override </span>{</div><div class="line">        <span class="keywordflow">return</span> inputConnector-&gt;isInputTerminated();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="tut1-task-notes"></a>
Notes</h3>
<ul>
<li>The input and output types of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> are defined by the first and second template parameters, respectively.</li>
<li>Memory leaks are avoided by using the C++11 std::shared_ptr class. When adding data with <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa" title="Adds results to the output list to be sent to the next connected ITask in a TaskGraph. ">htgs::ITask::addResult</a>, the memory pointer allocated will be automatically wrapped into a std::shared_ptr to ensure it gets freed once all references have finished referring to it. Alternatively, you can pass a std::shared_ptr to <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa" title="Adds results to the output list to be sent to the next connected ITask in a TaskGraph. ">htgs::ITask::addResult</a></li>
</ul>
<h2><a class="anchor" id="tut1-create-and-execute-taskgraph"></a>
Creating and Executing the htgs::TaskGraphConf</h2>
<p>The <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> is used to connect <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>'s into a graph that is executed concurrently. The premise of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> is to provide a separate of concerns between managing memory, dependencies, and computation. A <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> has an input and output type, which are used to produce and consume data to/from the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>.</p>
<p>These are the primary functions used to add a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> to a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></p>
<ol type="1">
<li><a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811" title="Sets the task that is consuming data from the input of the graph. ">htgs::TaskGraphConf::setGraphConsumerTask</a><ul>
<li>Sets the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> that will be consuming data that is inserted into the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> during execution</li>
<li>The input type of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> must match the input type of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>There can only be one <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> that consumes data from the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a><ul>
<li>If multiple are required, then a <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> can be used to distribute data among multiple <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>2) <a class="el" href="classhtgs_1_1_task_graph_conf.html#a0857e5a678b01922a513cd2327114864" title="Sets the task that is producing data for the output of the graph. ">htgs::TaskGraphConf::addGraphProducerTask</a></p><ul>
<li>Specifies a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> that will be producing data for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>The output type of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> must match the output type of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>There can be multiple <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> s producing data for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
</ul>
<p>3) <a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01" title="Adds an edge to the graph, where one task produces data for a consumer task. ">htgs::TaskGraphConf::addEdge</a> (Demonstrated in future tutorials)</p><ul>
<li>Adds an edge to the graph where one <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> produces data for another <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>, which consumes that data</li>
<li>The output type of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> producing data must match the input type of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> consuming that data</li>
</ul>
<p>4) <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">htgs::TaskGraphConf::addRuleEdge</a> (Demonstrated in future tutorials)</p><ul>
<li>Connects a <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> to a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> where a <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> determines when to produce data based on the state of the computation</li>
<li>Two variants are available<ul>
<li>Specifying std::shared_ptr for the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> allows the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> to be shared among multiple <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a><ul>
<li>Each <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> is access synchronously through a shared mutex</li>
</ul>
</li>
<li>Specifying without std::shared_ptr should not be shared among multiple <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a><ul>
<li>The <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> wraps the memory into a std::shared_ptr internally</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>5) <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">htgs::TaskGraphConf::addMemoryManagerEdge</a> (Demonstrated in future tutorials)</p><ul>
<li>Attaches a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> to a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>, so the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> can use <a class="el" href="classhtgs_1_1_i_task.html#a2d56ec21ba0130165ca35b5770bd5235" title="Retrieves memory from a memory edge. ">htgs::ITask::getMemory</a></li>
<li>Acts as a mechanism for sharing memory among multiple <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>Limited resource based on memory pool size</li>
<li>Specifies htgs::m_data_t, which can be released using <a class="el" href="classhtgs_1_1_i_task.html#ae791a014f6160e122b871891b60aafba" title="Releases memory onto a memory edge, which is transferred by the graph communicator. ">htgs::ITask::releaseMemory</a></li>
</ul>
<p>There are two steps necessary for adding data to a graph and ensuring the graph will finish executing.</p>
<ol type="1">
<li>(Optional) Specify an ITask that will be processing the input data with <a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811" title="Sets the task that is consuming data from the input of the graph. ">htgs::TaskGraphConf::setGraphConsumerTask</a><ul>
<li>Alternatively can specify a task in the graph as a <em>startTask</em> to begin processing immediately</li>
</ul>
</li>
<li><p class="startli">When there is no more data to be produced: <a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d" title="Decrements the input connector and wakes up any consumer of the graph&#39;s input if the input connector ...">htgs::TaskGraphConf::finishedProducingData</a></p><ul>
<li>Must be called to terminate the graph</li>
<li>If it is not called, then the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> will never finish executing</li>
</ul>
<p class="startli">To process the output of a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676" title="Consumes data from the output of a TaskGraph. ">htgs::TaskGraphConf::consumeData</a>. To determine if there is no more data being produced by the TaskGraph, use <a class="el" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea" title="Checks if the output of the TaskGraph has finished producing data. ">htgs::TaskGraphConf::isOutputTerminated</a>.</p>
</li>
</ol>
<p>To execute a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> use the <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a>. The <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a> will create and launch threads. If a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> has more than one thread specified, then the <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a> will duplicate the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> such that each thread will be responsible for a separate instance of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>.</p>
<p>The <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a> specifies the following functions:</p><ol type="1">
<li><a class="el" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9" title="Executes the Runtime. ">htgs::TaskGraphRuntime::executeRuntime</a> - Spawns and launches threads, returning back to the caller</li>
<li><a class="el" href="classhtgs_1_1_task_graph_runtime.html#a8f2eaf040695178b6f61db7b0ee16c89" title="Waits for the Runtime to finish executing. ">htgs::TaskGraphRuntime::waitForRuntime</a> - Waits for threads to finish (thread join)</li>
<li><a class="el" href="classhtgs_1_1_task_graph_runtime.html#a55210fa09f813799e7ee8d3512860d06" title="Executes the Runtime and then waits for it to finish processing. ">htgs::TaskGraphRuntime::executeAndWaitForRuntime</a> - Executes and then waits for the runtime to finish</li>
</ol>
<p>Calling <b>delete</b> on the runtime will release all memory associated with the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>, including <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> allocations.</p>
<h3><a class="anchor" id="tut1-main-function"></a>
Main function (create and execute TaskGraph)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_conf_8hpp.html">htgs/api/TaskGraphConf.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_runtime_8hpp.html">htgs/api/TaskGraphRuntime.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/AddTask.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="comment">// Creates the Task</span></div><div class="line">    AddTask *addTask = <span class="keyword">new</span> AddTask();</div><div class="line"></div><div class="line">    <span class="comment">// Creates the TaskGraph</span></div><div class="line">    <span class="keyword">auto</span> taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;InputData, OutputData&gt;</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Declares that AddTask will be processing the input of a TaskGraph</span></div><div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811">setGraphConsumerTask</a>(addTask);</div><div class="line"></div><div class="line">    <span class="comment">// Declares that AddTask will be producing data for the output of a TaskGraph</span></div><div class="line">    taskGraph-&gt;addGraphProducerTask(addTask);</div><div class="line"></div><div class="line">    <span class="comment">// Launch the taskGraph</span></div><div class="line">    <span class="keyword">auto</span> runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a>(taskGraph);</div><div class="line"></div><div class="line">    runtime-&gt;executeRuntime();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> numData = 10;</div><div class="line"></div><div class="line">    <span class="comment">// Main thread producing data</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numData; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> inputData = <span class="keyword">new</span> InputData(i, i);</div><div class="line">        taskGraph-&gt;produceData(inputData);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Indicate that the main thread has finished producing data</span></div><div class="line">    taskGraph-&gt;finishedProducingData();</div><div class="line"></div><div class="line">    <span class="comment">// Wait until the runtime has finished processing data</span></div><div class="line">    runtime-&gt;waitForRuntime();</div><div class="line"></div><div class="line">    <span class="comment">// Process the ouput of the TaskGraph until no more data is available</span></div><div class="line">    <span class="comment">// Could process this data prior to runtime-&gt;waitForRuntime()</span></div><div class="line">    <span class="keywordflow">while</span> (!taskGraph-&gt;isOutputTerminated())</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> data = taskGraph-&gt;consumeData();</div><div class="line"></div><div class="line">        <span class="comment">// Good idea to check for nullptr data in case termination makes its way out of consumeData from taskGraph</span></div><div class="line">        <span class="keywordflow">if</span> (data != <span class="keyword">nullptr</span>)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">int</span> result = data-&gt;getResult();</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Release all memory for the graph</span></div><div class="line">    <span class="keyword">delete</span> runtime;</div><div class="line">}</div></div><!-- fragment --><p>Sample execution: </p><div class="fragment"><div class="line">./tutorial1</div><div class="line">Result: 0</div><div class="line">Result: 2</div><div class="line">Result: 4</div><div class="line">Result: 6</div><div class="line">Result: 8</div><div class="line">Result: 10</div><div class="line">Result: 12</div><div class="line">Result: 14</div><div class="line">Result: 16</div><div class="line">Result: 18</div></div><!-- fragment --><h3><a class="anchor" id="tut1-debug"></a>
Debugging and profiling a htgs::TaskGraphConf</h3>
<p>If there are complications when running a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>, then the configuration can be saved as a dot file with the function <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a>, which can be visually shown with the following command 'dot -Tpng &lt;filename&gt; -o &lt;filename&gt;.png' from <a href="http://www.graphviz.org">Graphviz</a>. Below is an example dot file that is generated and the associated image representation:</p>
<p>Dot file generated using "taskGraph-&gt;writeDotToFile("tutorial1.dot")": </p><div class="fragment"><div class="line">digraph {</div><div class="line">node[shape=record, fontsize=10, fontname=&quot;Verdana&quot;];</div><div class="line">edge[fontsize=10, fontname=&quot;Verdana&quot;];</div><div class="line">graph [compound=true];</div><div class="line">x10f6380 -&gt; x10f6010;</div><div class="line">x10f6380[label=&quot;&quot;,shape=box,style=filled,color=black,width=.2,height=.2];</div><div class="line">x10f6010 -&gt; x10f6720;</div><div class="line">x10f6720[label=&quot;&quot;,shape=box,style=filled,color=black,width=.2,height=.2];</div><div class="line">x10f6010[label=&quot;x+y=z&quot;];</div><div class="line">}</div></div><!-- fragment --><p>And the image generated with GraphViz using "dot -Tpng tutorial1.dot -o tutorial1.png" </p><div class="image">
<img src="tutorial1.png" alt="tutorial1.png"/>
<div class="caption">
Tutorial1 TaskGraph</div></div>
<p>If the <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#accab4a128de5b389716347a285aa9094" title="Writes the dot representation of the task graph to disk with additional options such as profiling...">htgs::TaskGraphConf::writeDotToFile</a> is used after the <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a> has finished and the PROFILE directive has been defined, then profiling data will be generated within the dot file representation. Various flags can be used to customize the dot file, found in &lt;<a class="el" href="_task_graph_dot_gen_flags_8hpp.html" title="Defines DOTGEN flags used for dot file generation. ">htgs/types/TaskGraphDotGenFlags.hpp</a>&gt;.</p>
<h3><a class="anchor" id="taskgraph-notes"></a>
Notes</h3>
<ul>
<li>The input and output types for each Task being added must match based on the way they are being added into a TaskGraph<ul>
<li>Example 1: <a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01" title="Adds an edge to the graph, where one task produces data for a consumer task. ">htgs::TaskGraphConf::addEdge</a> types match based on output of producer and input of consumer</li>
<li>Example 2: <a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811" title="Sets the task that is consuming data from the input of the graph. ">htgs::TaskGraphConf::setGraphConsumerTask</a> types match based on input of graph and input on consumer</li>
</ul>
</li>
<li>To release all memory for HTGS, you only need to delete the runtime.</li>
<li>Threading is managed by the runtime, which will spawn threads and join on them.</li>
<li>If the main thread or some other component is producing data for a TaskGraph:<ol type="1">
<li>Specify the ITask that will be processing the input data with <a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811" title="Sets the task that is consuming data from the input of the graph. ">htgs::TaskGraphConf::setGraphConsumerTask</a></li>
<li>Always call <a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d" title="Decrements the input connector and wakes up any consumer of the graph&#39;s input if the input connector ...">htgs::TaskGraphConf::finishedProducingData</a> when there is no more data to be produced</li>
</ol>
</li>
<li>Use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676" title="Consumes data from the output of a TaskGraph. ">htgs::TaskGraphConf::consumeData</a> to retrieve the output from a TaskGraph.</li>
<li>Use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea" title="Checks if the output of the TaskGraph has finished producing data. ">htgs::TaskGraphConf::isOutputTerminated</a> to check if the TaskGraph has finished producing data.</li>
</ul>
<h1><a class="anchor" id="summary"></a>
Summary </h1>
<p>In this tutorial, we looked at the basics of the HTGS API.</p><ul>
<li>Data using <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a></li>
<li>Compute functions using the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> interface</li>
<li>Creating a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>Executing a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a> with the <a class="el" href="classhtgs_1_1_task_graph_runtime.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs::TaskGraphRuntime</a></li>
<li>Producing data for a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>Consuming data produced by a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
</ul>
<p>In <a class="el" href="tutorial2a.html">Tutorial2a</a> and <a class="el" href="tutorial2b.html">Tutorial2b</a>, we will introduce two operations that assist in representing algorithms that contain dependencies with the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> and strict memory limitations using the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>.</p>
<p>Additional information:</p><ul>
<li>Header files that begin the 'I' denote an interface that is to be implemented; examples: <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a> and <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>a <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> is managed by a <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">htgs::TaskManager</a> which works with the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a>'s input and output htgs::Connectors, and calls the underlying <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> functions.</li>
<li>The htgs::Task use the <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>, which are setup when adding an ITask to a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a></li>
<li>When transforming an algorithm into a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">htgs::TaskGraphConf</a>, it helps to create a dataflow representation first to aid in understanding data dependencies and parallelism. This is particularly useful when determining how to represent <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a>, which will be further demonstrated in <a class="el" href="tutorial2a.html">Tutorial2a</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
